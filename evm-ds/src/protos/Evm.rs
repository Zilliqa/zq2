// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `Evm.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct UInt128 {
    // message fields
    pub x0: u64,
    pub x1: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UInt128 {
    fn default() -> &'a UInt128 {
        <UInt128 as ::protobuf::Message>::default_instance()
    }
}

impl UInt128 {
    pub fn new() -> UInt128 {
        ::std::default::Default::default()
    }

    // uint64 x0 = 1;


    pub fn get_x0(&self) -> u64 {
        self.x0
    }
    pub fn clear_x0(&mut self) {
        self.x0 = 0;
    }

    // Param is passed by value, moved
    pub fn set_x0(&mut self, v: u64) {
        self.x0 = v;
    }

    // uint64 x1 = 2;


    pub fn get_x1(&self) -> u64 {
        self.x1
    }
    pub fn clear_x1(&mut self) {
        self.x1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_x1(&mut self, v: u64) {
        self.x1 = v;
    }
}

impl ::protobuf::Message for UInt128 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.x0 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.x1 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.x0 != 0 {
            my_size += ::protobuf::rt::value_size(1, self.x0, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.x1 != 0 {
            my_size += ::protobuf::rt::value_size(2, self.x1, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.x0 != 0 {
            os.write_uint64(1, self.x0)?;
        }
        if self.x1 != 0 {
            os.write_uint64(2, self.x1)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UInt128 {
        UInt128::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "x0",
                |m: &UInt128| { &m.x0 },
                |m: &mut UInt128| { &mut m.x0 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "x1",
                |m: &UInt128| { &m.x1 },
                |m: &mut UInt128| { &mut m.x1 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UInt128>(
                "UInt128",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UInt128 {
        static instance: ::protobuf::rt::LazyV2<UInt128> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UInt128::new)
    }
}

impl ::protobuf::Clear for UInt128 {
    fn clear(&mut self) {
        self.x0 = 0;
        self.x1 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UInt128 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UInt128 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UInt256 {
    // message fields
    pub x0: u64,
    pub x1: u64,
    pub x2: u64,
    pub x3: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UInt256 {
    fn default() -> &'a UInt256 {
        <UInt256 as ::protobuf::Message>::default_instance()
    }
}

impl UInt256 {
    pub fn new() -> UInt256 {
        ::std::default::Default::default()
    }

    // uint64 x0 = 1;


    pub fn get_x0(&self) -> u64 {
        self.x0
    }
    pub fn clear_x0(&mut self) {
        self.x0 = 0;
    }

    // Param is passed by value, moved
    pub fn set_x0(&mut self, v: u64) {
        self.x0 = v;
    }

    // uint64 x1 = 2;


    pub fn get_x1(&self) -> u64 {
        self.x1
    }
    pub fn clear_x1(&mut self) {
        self.x1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_x1(&mut self, v: u64) {
        self.x1 = v;
    }

    // uint64 x2 = 3;


    pub fn get_x2(&self) -> u64 {
        self.x2
    }
    pub fn clear_x2(&mut self) {
        self.x2 = 0;
    }

    // Param is passed by value, moved
    pub fn set_x2(&mut self, v: u64) {
        self.x2 = v;
    }

    // uint64 x3 = 4;


    pub fn get_x3(&self) -> u64 {
        self.x3
    }
    pub fn clear_x3(&mut self) {
        self.x3 = 0;
    }

    // Param is passed by value, moved
    pub fn set_x3(&mut self, v: u64) {
        self.x3 = v;
    }
}

impl ::protobuf::Message for UInt256 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.x0 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.x1 = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.x2 = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.x3 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.x0 != 0 {
            my_size += ::protobuf::rt::value_size(1, self.x0, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.x1 != 0 {
            my_size += ::protobuf::rt::value_size(2, self.x1, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.x2 != 0 {
            my_size += ::protobuf::rt::value_size(3, self.x2, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.x3 != 0 {
            my_size += ::protobuf::rt::value_size(4, self.x3, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.x0 != 0 {
            os.write_uint64(1, self.x0)?;
        }
        if self.x1 != 0 {
            os.write_uint64(2, self.x1)?;
        }
        if self.x2 != 0 {
            os.write_uint64(3, self.x2)?;
        }
        if self.x3 != 0 {
            os.write_uint64(4, self.x3)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UInt256 {
        UInt256::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "x0",
                |m: &UInt256| { &m.x0 },
                |m: &mut UInt256| { &mut m.x0 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "x1",
                |m: &UInt256| { &m.x1 },
                |m: &mut UInt256| { &mut m.x1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "x2",
                |m: &UInt256| { &m.x2 },
                |m: &mut UInt256| { &mut m.x2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "x3",
                |m: &UInt256| { &m.x3 },
                |m: &mut UInt256| { &mut m.x3 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UInt256>(
                "UInt256",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UInt256 {
        static instance: ::protobuf::rt::LazyV2<UInt256> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UInt256::new)
    }
}

impl ::protobuf::Clear for UInt256 {
    fn clear(&mut self) {
        self.x0 = 0;
        self.x1 = 0;
        self.x2 = 0;
        self.x3 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UInt256 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UInt256 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Address {
    // message fields
    pub x0: u32,
    pub x1: u64,
    pub x2: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Address {
    fn default() -> &'a Address {
        <Address as ::protobuf::Message>::default_instance()
    }
}

impl Address {
    pub fn new() -> Address {
        ::std::default::Default::default()
    }

    // fixed32 x0 = 1;


    pub fn get_x0(&self) -> u32 {
        self.x0
    }
    pub fn clear_x0(&mut self) {
        self.x0 = 0;
    }

    // Param is passed by value, moved
    pub fn set_x0(&mut self, v: u32) {
        self.x0 = v;
    }

    // fixed64 x1 = 2;


    pub fn get_x1(&self) -> u64 {
        self.x1
    }
    pub fn clear_x1(&mut self) {
        self.x1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_x1(&mut self, v: u64) {
        self.x1 = v;
    }

    // fixed64 x2 = 3;


    pub fn get_x2(&self) -> u64 {
        self.x2
    }
    pub fn clear_x2(&mut self) {
        self.x2 = 0;
    }

    // Param is passed by value, moved
    pub fn set_x2(&mut self, v: u64) {
        self.x2 = v;
    }
}

impl ::protobuf::Message for Address {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.x0 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.x1 = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.x2 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.x0 != 0 {
            my_size += 5;
        }
        if self.x1 != 0 {
            my_size += 9;
        }
        if self.x2 != 0 {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.x0 != 0 {
            os.write_fixed32(1, self.x0)?;
        }
        if self.x1 != 0 {
            os.write_fixed64(2, self.x1)?;
        }
        if self.x2 != 0 {
            os.write_fixed64(3, self.x2)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Address {
        Address::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "x0",
                |m: &Address| { &m.x0 },
                |m: &mut Address| { &mut m.x0 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "x1",
                |m: &Address| { &m.x1 },
                |m: &mut Address| { &mut m.x1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "x2",
                |m: &Address| { &m.x2 },
                |m: &mut Address| { &mut m.x2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Address>(
                "Address",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Address {
        static instance: ::protobuf::rt::LazyV2<Address> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Address::new)
    }
}

impl ::protobuf::Clear for Address {
    fn clear(&mut self) {
        self.x0 = 0;
        self.x1 = 0;
        self.x2 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Address {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct H256 {
    // message fields
    pub x0: u64,
    pub x1: u64,
    pub x2: u64,
    pub x3: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a H256 {
    fn default() -> &'a H256 {
        <H256 as ::protobuf::Message>::default_instance()
    }
}

impl H256 {
    pub fn new() -> H256 {
        ::std::default::Default::default()
    }

    // fixed64 x0 = 1;


    pub fn get_x0(&self) -> u64 {
        self.x0
    }
    pub fn clear_x0(&mut self) {
        self.x0 = 0;
    }

    // Param is passed by value, moved
    pub fn set_x0(&mut self, v: u64) {
        self.x0 = v;
    }

    // fixed64 x1 = 2;


    pub fn get_x1(&self) -> u64 {
        self.x1
    }
    pub fn clear_x1(&mut self) {
        self.x1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_x1(&mut self, v: u64) {
        self.x1 = v;
    }

    // fixed64 x2 = 3;


    pub fn get_x2(&self) -> u64 {
        self.x2
    }
    pub fn clear_x2(&mut self) {
        self.x2 = 0;
    }

    // Param is passed by value, moved
    pub fn set_x2(&mut self, v: u64) {
        self.x2 = v;
    }

    // fixed64 x3 = 4;


    pub fn get_x3(&self) -> u64 {
        self.x3
    }
    pub fn clear_x3(&mut self) {
        self.x3 = 0;
    }

    // Param is passed by value, moved
    pub fn set_x3(&mut self, v: u64) {
        self.x3 = v;
    }
}

impl ::protobuf::Message for H256 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.x0 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.x1 = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.x2 = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.x3 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.x0 != 0 {
            my_size += 9;
        }
        if self.x1 != 0 {
            my_size += 9;
        }
        if self.x2 != 0 {
            my_size += 9;
        }
        if self.x3 != 0 {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.x0 != 0 {
            os.write_fixed64(1, self.x0)?;
        }
        if self.x1 != 0 {
            os.write_fixed64(2, self.x1)?;
        }
        if self.x2 != 0 {
            os.write_fixed64(3, self.x2)?;
        }
        if self.x3 != 0 {
            os.write_fixed64(4, self.x3)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> H256 {
        H256::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "x0",
                |m: &H256| { &m.x0 },
                |m: &mut H256| { &mut m.x0 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "x1",
                |m: &H256| { &m.x1 },
                |m: &mut H256| { &mut m.x1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "x2",
                |m: &H256| { &m.x2 },
                |m: &mut H256| { &mut m.x2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "x3",
                |m: &H256| { &m.x3 },
                |m: &mut H256| { &mut m.x3 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<H256>(
                "H256",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static H256 {
        static instance: ::protobuf::rt::LazyV2<H256> = ::protobuf::rt::LazyV2::INIT;
        instance.get(H256::new)
    }
}

impl ::protobuf::Clear for H256 {
    fn clear(&mut self) {
        self.x0 = 0;
        self.x1 = 0;
        self.x2 = 0;
        self.x3 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for H256 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for H256 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EvmEvalExtras {
    // message fields
    pub chain_id: u32,
    pub block_timestamp: u64,
    pub block_gas_limit: u64,
    pub block_difficulty: u64,
    pub block_number: u64,
    pub gas_price: ::protobuf::SingularPtrField<UInt256>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EvmEvalExtras {
    fn default() -> &'a EvmEvalExtras {
        <EvmEvalExtras as ::protobuf::Message>::default_instance()
    }
}

impl EvmEvalExtras {
    pub fn new() -> EvmEvalExtras {
        ::std::default::Default::default()
    }

    // uint32 chain_id = 1;


    pub fn get_chain_id(&self) -> u32 {
        self.chain_id
    }
    pub fn clear_chain_id(&mut self) {
        self.chain_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chain_id(&mut self, v: u32) {
        self.chain_id = v;
    }

    // uint64 block_timestamp = 2;


    pub fn get_block_timestamp(&self) -> u64 {
        self.block_timestamp
    }
    pub fn clear_block_timestamp(&mut self) {
        self.block_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_timestamp(&mut self, v: u64) {
        self.block_timestamp = v;
    }

    // uint64 block_gas_limit = 3;


    pub fn get_block_gas_limit(&self) -> u64 {
        self.block_gas_limit
    }
    pub fn clear_block_gas_limit(&mut self) {
        self.block_gas_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_gas_limit(&mut self, v: u64) {
        self.block_gas_limit = v;
    }

    // uint64 block_difficulty = 4;


    pub fn get_block_difficulty(&self) -> u64 {
        self.block_difficulty
    }
    pub fn clear_block_difficulty(&mut self) {
        self.block_difficulty = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_difficulty(&mut self, v: u64) {
        self.block_difficulty = v;
    }

    // uint64 block_number = 5;


    pub fn get_block_number(&self) -> u64 {
        self.block_number
    }
    pub fn clear_block_number(&mut self) {
        self.block_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_number(&mut self, v: u64) {
        self.block_number = v;
    }

    // .evm.UInt256 gas_price = 6;


    pub fn get_gas_price(&self) -> &UInt256 {
        self.gas_price.as_ref().unwrap_or_else(|| <UInt256 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_gas_price(&mut self) {
        self.gas_price.clear();
    }

    pub fn has_gas_price(&self) -> bool {
        self.gas_price.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gas_price(&mut self, v: UInt256) {
        self.gas_price = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gas_price(&mut self) -> &mut UInt256 {
        if self.gas_price.is_none() {
            self.gas_price.set_default();
        }
        self.gas_price.as_mut().unwrap()
    }

    // Take field
    pub fn take_gas_price(&mut self) -> UInt256 {
        self.gas_price.take().unwrap_or_else(|| UInt256::new())
    }
}

impl ::protobuf::Message for EvmEvalExtras {
    fn is_initialized(&self) -> bool {
        for v in &self.gas_price {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.chain_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_timestamp = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_gas_limit = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_difficulty = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_number = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gas_price)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chain_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chain_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.block_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.block_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.block_gas_limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.block_gas_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.block_difficulty != 0 {
            my_size += ::protobuf::rt::value_size(4, self.block_difficulty, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.block_number != 0 {
            my_size += ::protobuf::rt::value_size(5, self.block_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.gas_price.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chain_id != 0 {
            os.write_uint32(1, self.chain_id)?;
        }
        if self.block_timestamp != 0 {
            os.write_uint64(2, self.block_timestamp)?;
        }
        if self.block_gas_limit != 0 {
            os.write_uint64(3, self.block_gas_limit)?;
        }
        if self.block_difficulty != 0 {
            os.write_uint64(4, self.block_difficulty)?;
        }
        if self.block_number != 0 {
            os.write_uint64(5, self.block_number)?;
        }
        if let Some(ref v) = self.gas_price.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EvmEvalExtras {
        EvmEvalExtras::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "chain_id",
                |m: &EvmEvalExtras| { &m.chain_id },
                |m: &mut EvmEvalExtras| { &mut m.chain_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "block_timestamp",
                |m: &EvmEvalExtras| { &m.block_timestamp },
                |m: &mut EvmEvalExtras| { &mut m.block_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "block_gas_limit",
                |m: &EvmEvalExtras| { &m.block_gas_limit },
                |m: &mut EvmEvalExtras| { &mut m.block_gas_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "block_difficulty",
                |m: &EvmEvalExtras| { &m.block_difficulty },
                |m: &mut EvmEvalExtras| { &mut m.block_difficulty },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "block_number",
                |m: &EvmEvalExtras| { &m.block_number },
                |m: &mut EvmEvalExtras| { &mut m.block_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UInt256>>(
                "gas_price",
                |m: &EvmEvalExtras| { &m.gas_price },
                |m: &mut EvmEvalExtras| { &mut m.gas_price },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EvmEvalExtras>(
                "EvmEvalExtras",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EvmEvalExtras {
        static instance: ::protobuf::rt::LazyV2<EvmEvalExtras> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EvmEvalExtras::new)
    }
}

impl ::protobuf::Clear for EvmEvalExtras {
    fn clear(&mut self) {
        self.chain_id = 0;
        self.block_timestamp = 0;
        self.block_gas_limit = 0;
        self.block_difficulty = 0;
        self.block_number = 0;
        self.gas_price.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EvmEvalExtras {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvmEvalExtras {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Storage {
    // message fields
    pub key: ::bytes::Bytes,
    pub value: ::bytes::Bytes,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Storage {
    fn default() -> &'a Storage {
        <Storage as ::protobuf::Message>::default_instance()
    }
}

impl Storage {
    pub fn new() -> Storage {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::bytes::Bytes) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::bytes::Bytes {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.key, ::bytes::Bytes::new())
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::bytes::Bytes) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::bytes::Bytes {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.value, ::bytes::Bytes::new())
    }
}

impl ::protobuf::Message for Storage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Storage {
        Storage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "key",
                |m: &Storage| { &m.key },
                |m: &mut Storage| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "value",
                |m: &Storage| { &m.value },
                |m: &mut Storage| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Storage>(
                "Storage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Storage {
        static instance: ::protobuf::rt::LazyV2<Storage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Storage::new)
    }
}

impl ::protobuf::Clear for Storage {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Storage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Storage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Apply {
    // message oneof groups
    pub apply: ::std::option::Option<Apply_oneof_apply>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Apply {
    fn default() -> &'a Apply {
        <Apply as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Apply_oneof_apply {
    modify(Apply_Modify),
    delete(Apply_Delete),
}

impl Apply {
    pub fn new() -> Apply {
        ::std::default::Default::default()
    }

    // .evm.Apply.Modify modify = 1;


    pub fn get_modify(&self) -> &Apply_Modify {
        match self.apply {
            ::std::option::Option::Some(Apply_oneof_apply::modify(ref v)) => v,
            _ => <Apply_Modify as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_modify(&mut self) {
        self.apply = ::std::option::Option::None;
    }

    pub fn has_modify(&self) -> bool {
        match self.apply {
            ::std::option::Option::Some(Apply_oneof_apply::modify(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_modify(&mut self, v: Apply_Modify) {
        self.apply = ::std::option::Option::Some(Apply_oneof_apply::modify(v))
    }

    // Mutable pointer to the field.
    pub fn mut_modify(&mut self) -> &mut Apply_Modify {
        if let ::std::option::Option::Some(Apply_oneof_apply::modify(_)) = self.apply {
        } else {
            self.apply = ::std::option::Option::Some(Apply_oneof_apply::modify(Apply_Modify::new()));
        }
        match self.apply {
            ::std::option::Option::Some(Apply_oneof_apply::modify(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_modify(&mut self) -> Apply_Modify {
        if self.has_modify() {
            match self.apply.take() {
                ::std::option::Option::Some(Apply_oneof_apply::modify(v)) => v,
                _ => panic!(),
            }
        } else {
            Apply_Modify::new()
        }
    }

    // .evm.Apply.Delete delete = 2;


    pub fn get_delete(&self) -> &Apply_Delete {
        match self.apply {
            ::std::option::Option::Some(Apply_oneof_apply::delete(ref v)) => v,
            _ => <Apply_Delete as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_delete(&mut self) {
        self.apply = ::std::option::Option::None;
    }

    pub fn has_delete(&self) -> bool {
        match self.apply {
            ::std::option::Option::Some(Apply_oneof_apply::delete(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete(&mut self, v: Apply_Delete) {
        self.apply = ::std::option::Option::Some(Apply_oneof_apply::delete(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete(&mut self) -> &mut Apply_Delete {
        if let ::std::option::Option::Some(Apply_oneof_apply::delete(_)) = self.apply {
        } else {
            self.apply = ::std::option::Option::Some(Apply_oneof_apply::delete(Apply_Delete::new()));
        }
        match self.apply {
            ::std::option::Option::Some(Apply_oneof_apply::delete(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete(&mut self) -> Apply_Delete {
        if self.has_delete() {
            match self.apply.take() {
                ::std::option::Option::Some(Apply_oneof_apply::delete(v)) => v,
                _ => panic!(),
            }
        } else {
            Apply_Delete::new()
        }
    }
}

impl ::protobuf::Message for Apply {
    fn is_initialized(&self) -> bool {
        if let Some(Apply_oneof_apply::modify(ref v)) = self.apply {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Apply_oneof_apply::delete(ref v)) = self.apply {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.apply = ::std::option::Option::Some(Apply_oneof_apply::modify(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.apply = ::std::option::Option::Some(Apply_oneof_apply::delete(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.apply {
            match v {
                &Apply_oneof_apply::modify(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Apply_oneof_apply::delete(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.apply {
            match v {
                &Apply_oneof_apply::modify(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Apply_oneof_apply::delete(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Apply {
        Apply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Apply_Modify>(
                "modify",
                Apply::has_modify,
                Apply::get_modify,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Apply_Delete>(
                "delete",
                Apply::has_delete,
                Apply::get_delete,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Apply>(
                "Apply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Apply {
        static instance: ::protobuf::rt::LazyV2<Apply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Apply::new)
    }
}

impl ::protobuf::Clear for Apply {
    fn clear(&mut self) {
        self.apply = ::std::option::Option::None;
        self.apply = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Apply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Apply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Apply_Delete {
    // message fields
    pub address: ::protobuf::SingularPtrField<Address>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Apply_Delete {
    fn default() -> &'a Apply_Delete {
        <Apply_Delete as ::protobuf::Message>::default_instance()
    }
}

impl Apply_Delete {
    pub fn new() -> Apply_Delete {
        ::std::default::Default::default()
    }

    // .evm.Address address = 1;


    pub fn get_address(&self) -> &Address {
        self.address.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: Address) {
        self.address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut Address {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> Address {
        self.address.take().unwrap_or_else(|| Address::new())
    }
}

impl ::protobuf::Message for Apply_Delete {
    fn is_initialized(&self) -> bool {
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.address.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Apply_Delete {
        Apply_Delete::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "address",
                |m: &Apply_Delete| { &m.address },
                |m: &mut Apply_Delete| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Apply_Delete>(
                "Apply.Delete",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Apply_Delete {
        static instance: ::protobuf::rt::LazyV2<Apply_Delete> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Apply_Delete::new)
    }
}

impl ::protobuf::Clear for Apply_Delete {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Apply_Delete {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Apply_Delete {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Apply_Modify {
    // message fields
    pub address: ::protobuf::SingularPtrField<Address>,
    pub balance: ::protobuf::SingularPtrField<UInt256>,
    pub nonce: ::protobuf::SingularPtrField<UInt256>,
    pub code: ::bytes::Bytes,
    pub storage: ::protobuf::RepeatedField<Storage>,
    pub reset_storage: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Apply_Modify {
    fn default() -> &'a Apply_Modify {
        <Apply_Modify as ::protobuf::Message>::default_instance()
    }
}

impl Apply_Modify {
    pub fn new() -> Apply_Modify {
        ::std::default::Default::default()
    }

    // .evm.Address address = 1;


    pub fn get_address(&self) -> &Address {
        self.address.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: Address) {
        self.address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut Address {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> Address {
        self.address.take().unwrap_or_else(|| Address::new())
    }

    // .evm.UInt256 balance = 2;


    pub fn get_balance(&self) -> &UInt256 {
        self.balance.as_ref().unwrap_or_else(|| <UInt256 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_balance(&mut self) {
        self.balance.clear();
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: UInt256) {
        self.balance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance(&mut self) -> &mut UInt256 {
        if self.balance.is_none() {
            self.balance.set_default();
        }
        self.balance.as_mut().unwrap()
    }

    // Take field
    pub fn take_balance(&mut self) -> UInt256 {
        self.balance.take().unwrap_or_else(|| UInt256::new())
    }

    // .evm.UInt256 nonce = 3;


    pub fn get_nonce(&self) -> &UInt256 {
        self.nonce.as_ref().unwrap_or_else(|| <UInt256 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_nonce(&mut self) {
        self.nonce.clear();
    }

    pub fn has_nonce(&self) -> bool {
        self.nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: UInt256) {
        self.nonce = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut UInt256 {
        if self.nonce.is_none() {
            self.nonce.set_default();
        }
        self.nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_nonce(&mut self) -> UInt256 {
        self.nonce.take().unwrap_or_else(|| UInt256::new())
    }

    // bytes code = 4;


    pub fn get_code(&self) -> &[u8] {
        &self.code
    }
    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::bytes::Bytes) {
        self.code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::bytes::Bytes {
        &mut self.code
    }

    // Take field
    pub fn take_code(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.code, ::bytes::Bytes::new())
    }

    // repeated .evm.Storage storage = 5;


    pub fn get_storage(&self) -> &[Storage] {
        &self.storage
    }
    pub fn clear_storage(&mut self) {
        self.storage.clear();
    }

    // Param is passed by value, moved
    pub fn set_storage(&mut self, v: ::protobuf::RepeatedField<Storage>) {
        self.storage = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storage(&mut self) -> &mut ::protobuf::RepeatedField<Storage> {
        &mut self.storage
    }

    // Take field
    pub fn take_storage(&mut self) -> ::protobuf::RepeatedField<Storage> {
        ::std::mem::replace(&mut self.storage, ::protobuf::RepeatedField::new())
    }

    // bool reset_storage = 6;


    pub fn get_reset_storage(&self) -> bool {
        self.reset_storage
    }
    pub fn clear_reset_storage(&mut self) {
        self.reset_storage = false;
    }

    // Param is passed by value, moved
    pub fn set_reset_storage(&mut self, v: bool) {
        self.reset_storage = v;
    }
}

impl ::protobuf::Message for Apply_Modify {
    fn is_initialized(&self) -> bool {
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.balance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nonce {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.storage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.balance)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nonce)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.code)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.storage)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reset_storage = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nonce.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.code);
        }
        for value in &self.storage {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.reset_storage != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.address.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.balance.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nonce.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.code.is_empty() {
            os.write_bytes(4, &self.code)?;
        }
        for v in &self.storage {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.reset_storage != false {
            os.write_bool(6, self.reset_storage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Apply_Modify {
        Apply_Modify::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "address",
                |m: &Apply_Modify| { &m.address },
                |m: &mut Apply_Modify| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UInt256>>(
                "balance",
                |m: &Apply_Modify| { &m.balance },
                |m: &mut Apply_Modify| { &mut m.balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UInt256>>(
                "nonce",
                |m: &Apply_Modify| { &m.nonce },
                |m: &mut Apply_Modify| { &mut m.nonce },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "code",
                |m: &Apply_Modify| { &m.code },
                |m: &mut Apply_Modify| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Storage>>(
                "storage",
                |m: &Apply_Modify| { &m.storage },
                |m: &mut Apply_Modify| { &mut m.storage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reset_storage",
                |m: &Apply_Modify| { &m.reset_storage },
                |m: &mut Apply_Modify| { &mut m.reset_storage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Apply_Modify>(
                "Apply.Modify",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Apply_Modify {
        static instance: ::protobuf::rt::LazyV2<Apply_Modify> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Apply_Modify::new)
    }
}

impl ::protobuf::Clear for Apply_Modify {
    fn clear(&mut self) {
        self.address.clear();
        self.balance.clear();
        self.nonce.clear();
        self.code.clear();
        self.storage.clear();
        self.reset_storage = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Apply_Modify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Apply_Modify {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Continuation {
    // message fields
    pub id: u64,
    pub feedback_type: Continuation_Type,
    pub logs: ::protobuf::RepeatedField<EvmLog>,
    pub succeeded: bool,
    // message oneof groups
    pub feedback_data: ::std::option::Option<Continuation_oneof_feedback_data>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Continuation {
    fn default() -> &'a Continuation {
        <Continuation as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Continuation_oneof_feedback_data {
    address(Address),
    calldata(Continuation_Call),
}

impl Continuation {
    pub fn new() -> Continuation {
        ::std::default::Default::default()
    }

    // uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = v;
    }

    // .evm.Continuation.Type feedback_type = 2;


    pub fn get_feedback_type(&self) -> Continuation_Type {
        self.feedback_type
    }
    pub fn clear_feedback_type(&mut self) {
        self.feedback_type = Continuation_Type::CALL;
    }

    // Param is passed by value, moved
    pub fn set_feedback_type(&mut self, v: Continuation_Type) {
        self.feedback_type = v;
    }

    // .evm.Address address = 3;


    pub fn get_address(&self) -> &Address {
        match self.feedback_data {
            ::std::option::Option::Some(Continuation_oneof_feedback_data::address(ref v)) => v,
            _ => <Address as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_address(&mut self) {
        self.feedback_data = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        match self.feedback_data {
            ::std::option::Option::Some(Continuation_oneof_feedback_data::address(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: Address) {
        self.feedback_data = ::std::option::Option::Some(Continuation_oneof_feedback_data::address(v))
    }

    // Mutable pointer to the field.
    pub fn mut_address(&mut self) -> &mut Address {
        if let ::std::option::Option::Some(Continuation_oneof_feedback_data::address(_)) = self.feedback_data {
        } else {
            self.feedback_data = ::std::option::Option::Some(Continuation_oneof_feedback_data::address(Address::new()));
        }
        match self.feedback_data {
            ::std::option::Option::Some(Continuation_oneof_feedback_data::address(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_address(&mut self) -> Address {
        if self.has_address() {
            match self.feedback_data.take() {
                ::std::option::Option::Some(Continuation_oneof_feedback_data::address(v)) => v,
                _ => panic!(),
            }
        } else {
            Address::new()
        }
    }

    // .evm.Continuation.Call calldata = 4;


    pub fn get_calldata(&self) -> &Continuation_Call {
        match self.feedback_data {
            ::std::option::Option::Some(Continuation_oneof_feedback_data::calldata(ref v)) => v,
            _ => <Continuation_Call as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_calldata(&mut self) {
        self.feedback_data = ::std::option::Option::None;
    }

    pub fn has_calldata(&self) -> bool {
        match self.feedback_data {
            ::std::option::Option::Some(Continuation_oneof_feedback_data::calldata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_calldata(&mut self, v: Continuation_Call) {
        self.feedback_data = ::std::option::Option::Some(Continuation_oneof_feedback_data::calldata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_calldata(&mut self) -> &mut Continuation_Call {
        if let ::std::option::Option::Some(Continuation_oneof_feedback_data::calldata(_)) = self.feedback_data {
        } else {
            self.feedback_data = ::std::option::Option::Some(Continuation_oneof_feedback_data::calldata(Continuation_Call::new()));
        }
        match self.feedback_data {
            ::std::option::Option::Some(Continuation_oneof_feedback_data::calldata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_calldata(&mut self) -> Continuation_Call {
        if self.has_calldata() {
            match self.feedback_data.take() {
                ::std::option::Option::Some(Continuation_oneof_feedback_data::calldata(v)) => v,
                _ => panic!(),
            }
        } else {
            Continuation_Call::new()
        }
    }

    // repeated .evm.EvmLog logs = 5;


    pub fn get_logs(&self) -> &[EvmLog] {
        &self.logs
    }
    pub fn clear_logs(&mut self) {
        self.logs.clear();
    }

    // Param is passed by value, moved
    pub fn set_logs(&mut self, v: ::protobuf::RepeatedField<EvmLog>) {
        self.logs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logs(&mut self) -> &mut ::protobuf::RepeatedField<EvmLog> {
        &mut self.logs
    }

    // Take field
    pub fn take_logs(&mut self) -> ::protobuf::RepeatedField<EvmLog> {
        ::std::mem::replace(&mut self.logs, ::protobuf::RepeatedField::new())
    }

    // bool succeeded = 6;


    pub fn get_succeeded(&self) -> bool {
        self.succeeded
    }
    pub fn clear_succeeded(&mut self) {
        self.succeeded = false;
    }

    // Param is passed by value, moved
    pub fn set_succeeded(&mut self, v: bool) {
        self.succeeded = v;
    }
}

impl ::protobuf::Message for Continuation {
    fn is_initialized(&self) -> bool {
        if let Some(Continuation_oneof_feedback_data::address(ref v)) = self.feedback_data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Continuation_oneof_feedback_data::calldata(ref v)) = self.feedback_data {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.logs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.feedback_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.feedback_data = ::std::option::Option::Some(Continuation_oneof_feedback_data::address(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.feedback_data = ::std::option::Option::Some(Continuation_oneof_feedback_data::calldata(is.read_message()?));
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logs)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.succeeded = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.feedback_type != Continuation_Type::CALL {
            my_size += ::protobuf::rt::enum_size(2, self.feedback_type);
        }
        for value in &self.logs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.succeeded != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.feedback_data {
            match v {
                &Continuation_oneof_feedback_data::address(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Continuation_oneof_feedback_data::calldata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        if self.feedback_type != Continuation_Type::CALL {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.feedback_type))?;
        }
        for v in &self.logs {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.succeeded != false {
            os.write_bool(6, self.succeeded)?;
        }
        if let ::std::option::Option::Some(ref v) = self.feedback_data {
            match v {
                &Continuation_oneof_feedback_data::address(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Continuation_oneof_feedback_data::calldata(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Continuation {
        Continuation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &Continuation| { &m.id },
                |m: &mut Continuation| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Continuation_Type>>(
                "feedback_type",
                |m: &Continuation| { &m.feedback_type },
                |m: &mut Continuation| { &mut m.feedback_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Address>(
                "address",
                Continuation::has_address,
                Continuation::get_address,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Continuation_Call>(
                "calldata",
                Continuation::has_calldata,
                Continuation::get_calldata,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EvmLog>>(
                "logs",
                |m: &Continuation| { &m.logs },
                |m: &mut Continuation| { &mut m.logs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "succeeded",
                |m: &Continuation| { &m.succeeded },
                |m: &mut Continuation| { &mut m.succeeded },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Continuation>(
                "Continuation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Continuation {
        static instance: ::protobuf::rt::LazyV2<Continuation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Continuation::new)
    }
}

impl ::protobuf::Clear for Continuation {
    fn clear(&mut self) {
        self.id = 0;
        self.feedback_type = Continuation_Type::CALL;
        self.feedback_data = ::std::option::Option::None;
        self.feedback_data = ::std::option::Option::None;
        self.logs.clear();
        self.succeeded = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Continuation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Continuation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Continuation_Call {
    // message fields
    pub data: ::bytes::Bytes,
    pub memory_offset: ::protobuf::SingularPtrField<UInt256>,
    pub offset_len: ::protobuf::SingularPtrField<UInt256>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Continuation_Call {
    fn default() -> &'a Continuation_Call {
        <Continuation_Call as ::protobuf::Message>::default_instance()
    }
}

impl Continuation_Call {
    pub fn new() -> Continuation_Call {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.data, ::bytes::Bytes::new())
    }

    // .evm.UInt256 memory_offset = 2;


    pub fn get_memory_offset(&self) -> &UInt256 {
        self.memory_offset.as_ref().unwrap_or_else(|| <UInt256 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_memory_offset(&mut self) {
        self.memory_offset.clear();
    }

    pub fn has_memory_offset(&self) -> bool {
        self.memory_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memory_offset(&mut self, v: UInt256) {
        self.memory_offset = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_memory_offset(&mut self) -> &mut UInt256 {
        if self.memory_offset.is_none() {
            self.memory_offset.set_default();
        }
        self.memory_offset.as_mut().unwrap()
    }

    // Take field
    pub fn take_memory_offset(&mut self) -> UInt256 {
        self.memory_offset.take().unwrap_or_else(|| UInt256::new())
    }

    // .evm.UInt256 offset_len = 3;


    pub fn get_offset_len(&self) -> &UInt256 {
        self.offset_len.as_ref().unwrap_or_else(|| <UInt256 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_offset_len(&mut self) {
        self.offset_len.clear();
    }

    pub fn has_offset_len(&self) -> bool {
        self.offset_len.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset_len(&mut self, v: UInt256) {
        self.offset_len = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offset_len(&mut self) -> &mut UInt256 {
        if self.offset_len.is_none() {
            self.offset_len.set_default();
        }
        self.offset_len.as_mut().unwrap()
    }

    // Take field
    pub fn take_offset_len(&mut self) -> UInt256 {
        self.offset_len.take().unwrap_or_else(|| UInt256::new())
    }
}

impl ::protobuf::Message for Continuation_Call {
    fn is_initialized(&self) -> bool {
        for v in &self.memory_offset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.offset_len {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.memory_offset)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.offset_len)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if let Some(ref v) = self.memory_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.offset_len.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if let Some(ref v) = self.memory_offset.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.offset_len.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Continuation_Call {
        Continuation_Call::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "data",
                |m: &Continuation_Call| { &m.data },
                |m: &mut Continuation_Call| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UInt256>>(
                "memory_offset",
                |m: &Continuation_Call| { &m.memory_offset },
                |m: &mut Continuation_Call| { &mut m.memory_offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UInt256>>(
                "offset_len",
                |m: &Continuation_Call| { &m.offset_len },
                |m: &mut Continuation_Call| { &mut m.offset_len },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Continuation_Call>(
                "Continuation.Call",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Continuation_Call {
        static instance: ::protobuf::rt::LazyV2<Continuation_Call> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Continuation_Call::new)
    }
}

impl ::protobuf::Clear for Continuation_Call {
    fn clear(&mut self) {
        self.data.clear();
        self.memory_offset.clear();
        self.offset_len.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Continuation_Call {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Continuation_Call {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Continuation_Type {
    CALL = 0,
    CREATE = 1,
}

impl ::protobuf::ProtobufEnum for Continuation_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Continuation_Type> {
        match value {
            0 => ::std::option::Option::Some(Continuation_Type::CALL),
            1 => ::std::option::Option::Some(Continuation_Type::CREATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Continuation_Type] = &[
            Continuation_Type::CALL,
            Continuation_Type::CREATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Continuation_Type>("Continuation.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Continuation_Type {
}

impl ::std::default::Default for Continuation_Type {
    fn default() -> Self {
        Continuation_Type::CALL
    }
}

impl ::protobuf::reflect::ProtobufValue for Continuation_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EvmArgs {
    // message fields
    pub address: ::protobuf::SingularPtrField<Address>,
    pub origin: ::protobuf::SingularPtrField<Address>,
    pub code: ::bytes::Bytes,
    pub data: ::bytes::Bytes,
    pub apparent_value: ::protobuf::SingularPtrField<UInt256>,
    pub gas_limit: u64,
    pub extras: ::protobuf::SingularPtrField<EvmEvalExtras>,
    pub estimate: bool,
    pub context: ::protobuf::Chars,
    pub continuation: ::protobuf::SingularPtrField<Continuation>,
    pub enable_cps: bool,
    pub tx_trace_enabled: bool,
    pub tx_trace: ::protobuf::Chars,
    pub is_static_call: bool,
    pub caller: ::protobuf::SingularPtrField<Address>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EvmArgs {
    fn default() -> &'a EvmArgs {
        <EvmArgs as ::protobuf::Message>::default_instance()
    }
}

impl EvmArgs {
    pub fn new() -> EvmArgs {
        ::std::default::Default::default()
    }

    // .evm.Address address = 1;


    pub fn get_address(&self) -> &Address {
        self.address.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: Address) {
        self.address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut Address {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> Address {
        self.address.take().unwrap_or_else(|| Address::new())
    }

    // .evm.Address origin = 2;


    pub fn get_origin(&self) -> &Address {
        self.origin.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_origin(&mut self) {
        self.origin.clear();
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: Address) {
        self.origin = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origin(&mut self) -> &mut Address {
        if self.origin.is_none() {
            self.origin.set_default();
        }
        self.origin.as_mut().unwrap()
    }

    // Take field
    pub fn take_origin(&mut self) -> Address {
        self.origin.take().unwrap_or_else(|| Address::new())
    }

    // bytes code = 3;


    pub fn get_code(&self) -> &[u8] {
        &self.code
    }
    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::bytes::Bytes) {
        self.code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::bytes::Bytes {
        &mut self.code
    }

    // Take field
    pub fn take_code(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.code, ::bytes::Bytes::new())
    }

    // bytes data = 4;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.data, ::bytes::Bytes::new())
    }

    // .evm.UInt256 apparent_value = 5;


    pub fn get_apparent_value(&self) -> &UInt256 {
        self.apparent_value.as_ref().unwrap_or_else(|| <UInt256 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_apparent_value(&mut self) {
        self.apparent_value.clear();
    }

    pub fn has_apparent_value(&self) -> bool {
        self.apparent_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apparent_value(&mut self, v: UInt256) {
        self.apparent_value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apparent_value(&mut self) -> &mut UInt256 {
        if self.apparent_value.is_none() {
            self.apparent_value.set_default();
        }
        self.apparent_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_apparent_value(&mut self) -> UInt256 {
        self.apparent_value.take().unwrap_or_else(|| UInt256::new())
    }

    // uint64 gas_limit = 6;


    pub fn get_gas_limit(&self) -> u64 {
        self.gas_limit
    }
    pub fn clear_gas_limit(&mut self) {
        self.gas_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_gas_limit(&mut self, v: u64) {
        self.gas_limit = v;
    }

    // .evm.EvmEvalExtras extras = 7;


    pub fn get_extras(&self) -> &EvmEvalExtras {
        self.extras.as_ref().unwrap_or_else(|| <EvmEvalExtras as ::protobuf::Message>::default_instance())
    }
    pub fn clear_extras(&mut self) {
        self.extras.clear();
    }

    pub fn has_extras(&self) -> bool {
        self.extras.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extras(&mut self, v: EvmEvalExtras) {
        self.extras = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extras(&mut self) -> &mut EvmEvalExtras {
        if self.extras.is_none() {
            self.extras.set_default();
        }
        self.extras.as_mut().unwrap()
    }

    // Take field
    pub fn take_extras(&mut self) -> EvmEvalExtras {
        self.extras.take().unwrap_or_else(|| EvmEvalExtras::new())
    }

    // bool estimate = 8;


    pub fn get_estimate(&self) -> bool {
        self.estimate
    }
    pub fn clear_estimate(&mut self) {
        self.estimate = false;
    }

    // Param is passed by value, moved
    pub fn set_estimate(&mut self, v: bool) {
        self.estimate = v;
    }

    // string context = 9;


    pub fn get_context(&self) -> &str {
        &self.context
    }
    pub fn clear_context(&mut self) {
        ::protobuf::Clear::clear(&mut self.context);
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: ::protobuf::Chars) {
        self.context = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut ::protobuf::Chars {
        &mut self.context
    }

    // Take field
    pub fn take_context(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.context, ::protobuf::Chars::new())
    }

    // .evm.Continuation continuation = 10;


    pub fn get_continuation(&self) -> &Continuation {
        self.continuation.as_ref().unwrap_or_else(|| <Continuation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_continuation(&mut self) {
        self.continuation.clear();
    }

    pub fn has_continuation(&self) -> bool {
        self.continuation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_continuation(&mut self, v: Continuation) {
        self.continuation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_continuation(&mut self) -> &mut Continuation {
        if self.continuation.is_none() {
            self.continuation.set_default();
        }
        self.continuation.as_mut().unwrap()
    }

    // Take field
    pub fn take_continuation(&mut self) -> Continuation {
        self.continuation.take().unwrap_or_else(|| Continuation::new())
    }

    // bool enable_cps = 11;


    pub fn get_enable_cps(&self) -> bool {
        self.enable_cps
    }
    pub fn clear_enable_cps(&mut self) {
        self.enable_cps = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_cps(&mut self, v: bool) {
        self.enable_cps = v;
    }

    // bool tx_trace_enabled = 12;


    pub fn get_tx_trace_enabled(&self) -> bool {
        self.tx_trace_enabled
    }
    pub fn clear_tx_trace_enabled(&mut self) {
        self.tx_trace_enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_tx_trace_enabled(&mut self, v: bool) {
        self.tx_trace_enabled = v;
    }

    // string tx_trace = 13;


    pub fn get_tx_trace(&self) -> &str {
        &self.tx_trace
    }
    pub fn clear_tx_trace(&mut self) {
        ::protobuf::Clear::clear(&mut self.tx_trace);
    }

    // Param is passed by value, moved
    pub fn set_tx_trace(&mut self, v: ::protobuf::Chars) {
        self.tx_trace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_trace(&mut self) -> &mut ::protobuf::Chars {
        &mut self.tx_trace
    }

    // Take field
    pub fn take_tx_trace(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.tx_trace, ::protobuf::Chars::new())
    }

    // bool is_static_call = 14;


    pub fn get_is_static_call(&self) -> bool {
        self.is_static_call
    }
    pub fn clear_is_static_call(&mut self) {
        self.is_static_call = false;
    }

    // Param is passed by value, moved
    pub fn set_is_static_call(&mut self, v: bool) {
        self.is_static_call = v;
    }

    // .evm.Address caller = 15;


    pub fn get_caller(&self) -> &Address {
        self.caller.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_caller(&mut self) {
        self.caller.clear();
    }

    pub fn has_caller(&self) -> bool {
        self.caller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller(&mut self, v: Address) {
        self.caller = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caller(&mut self) -> &mut Address {
        if self.caller.is_none() {
            self.caller.set_default();
        }
        self.caller.as_mut().unwrap()
    }

    // Take field
    pub fn take_caller(&mut self) -> Address {
        self.caller.take().unwrap_or_else(|| Address::new())
    }
}

impl ::protobuf::Message for EvmArgs {
    fn is_initialized(&self) -> bool {
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.origin {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apparent_value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extras {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.continuation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.caller {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.origin)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.code)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.data)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.apparent_value)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gas_limit = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.extras)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.estimate = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.context)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.continuation)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_cps = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tx_trace_enabled = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.tx_trace)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_static_call = tmp;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.caller)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.code);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.data);
        }
        if let Some(ref v) = self.apparent_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.gas_limit != 0 {
            my_size += ::protobuf::rt::value_size(6, self.gas_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extras.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.estimate != false {
            my_size += 2;
        }
        if !self.context.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.context);
        }
        if let Some(ref v) = self.continuation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.enable_cps != false {
            my_size += 2;
        }
        if self.tx_trace_enabled != false {
            my_size += 2;
        }
        if !self.tx_trace.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.tx_trace);
        }
        if self.is_static_call != false {
            my_size += 2;
        }
        if let Some(ref v) = self.caller.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.address.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.origin.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.code.is_empty() {
            os.write_bytes(3, &self.code)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(4, &self.data)?;
        }
        if let Some(ref v) = self.apparent_value.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.gas_limit != 0 {
            os.write_uint64(6, self.gas_limit)?;
        }
        if let Some(ref v) = self.extras.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.estimate != false {
            os.write_bool(8, self.estimate)?;
        }
        if !self.context.is_empty() {
            os.write_string(9, &self.context)?;
        }
        if let Some(ref v) = self.continuation.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.enable_cps != false {
            os.write_bool(11, self.enable_cps)?;
        }
        if self.tx_trace_enabled != false {
            os.write_bool(12, self.tx_trace_enabled)?;
        }
        if !self.tx_trace.is_empty() {
            os.write_string(13, &self.tx_trace)?;
        }
        if self.is_static_call != false {
            os.write_bool(14, self.is_static_call)?;
        }
        if let Some(ref v) = self.caller.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EvmArgs {
        EvmArgs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "address",
                |m: &EvmArgs| { &m.address },
                |m: &mut EvmArgs| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "origin",
                |m: &EvmArgs| { &m.origin },
                |m: &mut EvmArgs| { &mut m.origin },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "code",
                |m: &EvmArgs| { &m.code },
                |m: &mut EvmArgs| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "data",
                |m: &EvmArgs| { &m.data },
                |m: &mut EvmArgs| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UInt256>>(
                "apparent_value",
                |m: &EvmArgs| { &m.apparent_value },
                |m: &mut EvmArgs| { &mut m.apparent_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "gas_limit",
                |m: &EvmArgs| { &m.gas_limit },
                |m: &mut EvmArgs| { &mut m.gas_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EvmEvalExtras>>(
                "extras",
                |m: &EvmArgs| { &m.extras },
                |m: &mut EvmArgs| { &mut m.extras },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "estimate",
                |m: &EvmArgs| { &m.estimate },
                |m: &mut EvmArgs| { &mut m.estimate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                "context",
                |m: &EvmArgs| { &m.context },
                |m: &mut EvmArgs| { &mut m.context },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Continuation>>(
                "continuation",
                |m: &EvmArgs| { &m.continuation },
                |m: &mut EvmArgs| { &mut m.continuation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_cps",
                |m: &EvmArgs| { &m.enable_cps },
                |m: &mut EvmArgs| { &mut m.enable_cps },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tx_trace_enabled",
                |m: &EvmArgs| { &m.tx_trace_enabled },
                |m: &mut EvmArgs| { &mut m.tx_trace_enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                "tx_trace",
                |m: &EvmArgs| { &m.tx_trace },
                |m: &mut EvmArgs| { &mut m.tx_trace },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_static_call",
                |m: &EvmArgs| { &m.is_static_call },
                |m: &mut EvmArgs| { &mut m.is_static_call },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "caller",
                |m: &EvmArgs| { &m.caller },
                |m: &mut EvmArgs| { &mut m.caller },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EvmArgs>(
                "EvmArgs",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EvmArgs {
        static instance: ::protobuf::rt::LazyV2<EvmArgs> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EvmArgs::new)
    }
}

impl ::protobuf::Clear for EvmArgs {
    fn clear(&mut self) {
        self.address.clear();
        self.origin.clear();
        self.code.clear();
        self.data.clear();
        self.apparent_value.clear();
        self.gas_limit = 0;
        self.extras.clear();
        self.estimate = false;
        ::protobuf::Clear::clear(&mut self.context);
        self.continuation.clear();
        self.enable_cps = false;
        self.tx_trace_enabled = false;
        ::protobuf::Clear::clear(&mut self.tx_trace);
        self.is_static_call = false;
        self.caller.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EvmArgs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvmArgs {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EvmLog {
    // message fields
    pub address: ::protobuf::SingularPtrField<Address>,
    pub topics: ::protobuf::RepeatedField<H256>,
    pub data: ::bytes::Bytes,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EvmLog {
    fn default() -> &'a EvmLog {
        <EvmLog as ::protobuf::Message>::default_instance()
    }
}

impl EvmLog {
    pub fn new() -> EvmLog {
        ::std::default::Default::default()
    }

    // .evm.Address address = 1;


    pub fn get_address(&self) -> &Address {
        self.address.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: Address) {
        self.address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut Address {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> Address {
        self.address.take().unwrap_or_else(|| Address::new())
    }

    // repeated .evm.H256 topics = 2;


    pub fn get_topics(&self) -> &[H256] {
        &self.topics
    }
    pub fn clear_topics(&mut self) {
        self.topics.clear();
    }

    // Param is passed by value, moved
    pub fn set_topics(&mut self, v: ::protobuf::RepeatedField<H256>) {
        self.topics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_topics(&mut self) -> &mut ::protobuf::RepeatedField<H256> {
        &mut self.topics
    }

    // Take field
    pub fn take_topics(&mut self) -> ::protobuf::RepeatedField<H256> {
        ::std::mem::replace(&mut self.topics, ::protobuf::RepeatedField::new())
    }

    // bytes data = 3;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.data, ::bytes::Bytes::new())
    }
}

impl ::protobuf::Message for EvmLog {
    fn is_initialized(&self) -> bool {
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.topics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.topics)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.topics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.address.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.topics {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EvmLog {
        EvmLog::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "address",
                |m: &EvmLog| { &m.address },
                |m: &mut EvmLog| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<H256>>(
                "topics",
                |m: &EvmLog| { &m.topics },
                |m: &mut EvmLog| { &mut m.topics },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "data",
                |m: &EvmLog| { &m.data },
                |m: &mut EvmLog| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EvmLog>(
                "EvmLog",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EvmLog {
        static instance: ::protobuf::rt::LazyV2<EvmLog> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EvmLog::new)
    }
}

impl ::protobuf::Clear for EvmLog {
    fn clear(&mut self) {
        self.address.clear();
        self.topics.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EvmLog {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvmLog {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExitReason {
    // message oneof groups
    pub exit_reason: ::std::option::Option<ExitReason_oneof_exit_reason>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExitReason {
    fn default() -> &'a ExitReason {
        <ExitReason as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ExitReason_oneof_exit_reason {
    succeed(ExitReason_Succeed),
    error(ExitReason_Error),
    revert(ExitReason_Revert),
    fatal(ExitReason_Fatal),
    trap(ExitReason_Trap),
}

impl ExitReason {
    pub fn new() -> ExitReason {
        ::std::default::Default::default()
    }

    // .evm.ExitReason.Succeed succeed = 1;


    pub fn get_succeed(&self) -> ExitReason_Succeed {
        match self.exit_reason {
            ::std::option::Option::Some(ExitReason_oneof_exit_reason::succeed(v)) => v,
            _ => ExitReason_Succeed::STOPPED,
        }
    }
    pub fn clear_succeed(&mut self) {
        self.exit_reason = ::std::option::Option::None;
    }

    pub fn has_succeed(&self) -> bool {
        match self.exit_reason {
            ::std::option::Option::Some(ExitReason_oneof_exit_reason::succeed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_succeed(&mut self, v: ExitReason_Succeed) {
        self.exit_reason = ::std::option::Option::Some(ExitReason_oneof_exit_reason::succeed(v))
    }

    // .evm.ExitReason.Error error = 2;


    pub fn get_error(&self) -> &ExitReason_Error {
        match self.exit_reason {
            ::std::option::Option::Some(ExitReason_oneof_exit_reason::error(ref v)) => v,
            _ => <ExitReason_Error as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_error(&mut self) {
        self.exit_reason = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.exit_reason {
            ::std::option::Option::Some(ExitReason_oneof_exit_reason::error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ExitReason_Error) {
        self.exit_reason = ::std::option::Option::Some(ExitReason_oneof_exit_reason::error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut ExitReason_Error {
        if let ::std::option::Option::Some(ExitReason_oneof_exit_reason::error(_)) = self.exit_reason {
        } else {
            self.exit_reason = ::std::option::Option::Some(ExitReason_oneof_exit_reason::error(ExitReason_Error::new()));
        }
        match self.exit_reason {
            ::std::option::Option::Some(ExitReason_oneof_exit_reason::error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> ExitReason_Error {
        if self.has_error() {
            match self.exit_reason.take() {
                ::std::option::Option::Some(ExitReason_oneof_exit_reason::error(v)) => v,
                _ => panic!(),
            }
        } else {
            ExitReason_Error::new()
        }
    }

    // .evm.ExitReason.Revert revert = 3;


    pub fn get_revert(&self) -> ExitReason_Revert {
        match self.exit_reason {
            ::std::option::Option::Some(ExitReason_oneof_exit_reason::revert(v)) => v,
            _ => ExitReason_Revert::REVERTED,
        }
    }
    pub fn clear_revert(&mut self) {
        self.exit_reason = ::std::option::Option::None;
    }

    pub fn has_revert(&self) -> bool {
        match self.exit_reason {
            ::std::option::Option::Some(ExitReason_oneof_exit_reason::revert(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_revert(&mut self, v: ExitReason_Revert) {
        self.exit_reason = ::std::option::Option::Some(ExitReason_oneof_exit_reason::revert(v))
    }

    // .evm.ExitReason.Fatal fatal = 4;


    pub fn get_fatal(&self) -> &ExitReason_Fatal {
        match self.exit_reason {
            ::std::option::Option::Some(ExitReason_oneof_exit_reason::fatal(ref v)) => v,
            _ => <ExitReason_Fatal as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_fatal(&mut self) {
        self.exit_reason = ::std::option::Option::None;
    }

    pub fn has_fatal(&self) -> bool {
        match self.exit_reason {
            ::std::option::Option::Some(ExitReason_oneof_exit_reason::fatal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fatal(&mut self, v: ExitReason_Fatal) {
        self.exit_reason = ::std::option::Option::Some(ExitReason_oneof_exit_reason::fatal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fatal(&mut self) -> &mut ExitReason_Fatal {
        if let ::std::option::Option::Some(ExitReason_oneof_exit_reason::fatal(_)) = self.exit_reason {
        } else {
            self.exit_reason = ::std::option::Option::Some(ExitReason_oneof_exit_reason::fatal(ExitReason_Fatal::new()));
        }
        match self.exit_reason {
            ::std::option::Option::Some(ExitReason_oneof_exit_reason::fatal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fatal(&mut self) -> ExitReason_Fatal {
        if self.has_fatal() {
            match self.exit_reason.take() {
                ::std::option::Option::Some(ExitReason_oneof_exit_reason::fatal(v)) => v,
                _ => panic!(),
            }
        } else {
            ExitReason_Fatal::new()
        }
    }

    // .evm.ExitReason.Trap trap = 5;


    pub fn get_trap(&self) -> &ExitReason_Trap {
        match self.exit_reason {
            ::std::option::Option::Some(ExitReason_oneof_exit_reason::trap(ref v)) => v,
            _ => <ExitReason_Trap as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_trap(&mut self) {
        self.exit_reason = ::std::option::Option::None;
    }

    pub fn has_trap(&self) -> bool {
        match self.exit_reason {
            ::std::option::Option::Some(ExitReason_oneof_exit_reason::trap(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_trap(&mut self, v: ExitReason_Trap) {
        self.exit_reason = ::std::option::Option::Some(ExitReason_oneof_exit_reason::trap(v))
    }

    // Mutable pointer to the field.
    pub fn mut_trap(&mut self) -> &mut ExitReason_Trap {
        if let ::std::option::Option::Some(ExitReason_oneof_exit_reason::trap(_)) = self.exit_reason {
        } else {
            self.exit_reason = ::std::option::Option::Some(ExitReason_oneof_exit_reason::trap(ExitReason_Trap::new()));
        }
        match self.exit_reason {
            ::std::option::Option::Some(ExitReason_oneof_exit_reason::trap(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_trap(&mut self) -> ExitReason_Trap {
        if self.has_trap() {
            match self.exit_reason.take() {
                ::std::option::Option::Some(ExitReason_oneof_exit_reason::trap(v)) => v,
                _ => panic!(),
            }
        } else {
            ExitReason_Trap::new()
        }
    }
}

impl ::protobuf::Message for ExitReason {
    fn is_initialized(&self) -> bool {
        if let Some(ExitReason_oneof_exit_reason::error(ref v)) = self.exit_reason {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ExitReason_oneof_exit_reason::fatal(ref v)) = self.exit_reason {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ExitReason_oneof_exit_reason::trap(ref v)) = self.exit_reason {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.exit_reason = ::std::option::Option::Some(ExitReason_oneof_exit_reason::succeed(is.read_enum()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.exit_reason = ::std::option::Option::Some(ExitReason_oneof_exit_reason::error(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.exit_reason = ::std::option::Option::Some(ExitReason_oneof_exit_reason::revert(is.read_enum()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.exit_reason = ::std::option::Option::Some(ExitReason_oneof_exit_reason::fatal(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.exit_reason = ::std::option::Option::Some(ExitReason_oneof_exit_reason::trap(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.exit_reason {
            match v {
                &ExitReason_oneof_exit_reason::succeed(v) => {
                    my_size += ::protobuf::rt::enum_size(1, v);
                },
                &ExitReason_oneof_exit_reason::error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ExitReason_oneof_exit_reason::revert(v) => {
                    my_size += ::protobuf::rt::enum_size(3, v);
                },
                &ExitReason_oneof_exit_reason::fatal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ExitReason_oneof_exit_reason::trap(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.exit_reason {
            match v {
                &ExitReason_oneof_exit_reason::succeed(v) => {
                    os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
                },
                &ExitReason_oneof_exit_reason::error(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ExitReason_oneof_exit_reason::revert(v) => {
                    os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
                },
                &ExitReason_oneof_exit_reason::fatal(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ExitReason_oneof_exit_reason::trap(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExitReason {
        ExitReason::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, ExitReason_Succeed>(
                "succeed",
                ExitReason::has_succeed,
                ExitReason::get_succeed,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ExitReason_Error>(
                "error",
                ExitReason::has_error,
                ExitReason::get_error,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, ExitReason_Revert>(
                "revert",
                ExitReason::has_revert,
                ExitReason::get_revert,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ExitReason_Fatal>(
                "fatal",
                ExitReason::has_fatal,
                ExitReason::get_fatal,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ExitReason_Trap>(
                "trap",
                ExitReason::has_trap,
                ExitReason::get_trap,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExitReason>(
                "ExitReason",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExitReason {
        static instance: ::protobuf::rt::LazyV2<ExitReason> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExitReason::new)
    }
}

impl ::protobuf::Clear for ExitReason {
    fn clear(&mut self) {
        self.exit_reason = ::std::option::Option::None;
        self.exit_reason = ::std::option::Option::None;
        self.exit_reason = ::std::option::Option::None;
        self.exit_reason = ::std::option::Option::None;
        self.exit_reason = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExitReason {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExitReason {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExitReason_Error {
    // message fields
    pub kind: ExitReason_Error_Kind,
    pub error_string: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExitReason_Error {
    fn default() -> &'a ExitReason_Error {
        <ExitReason_Error as ::protobuf::Message>::default_instance()
    }
}

impl ExitReason_Error {
    pub fn new() -> ExitReason_Error {
        ::std::default::Default::default()
    }

    // .evm.ExitReason.Error.Kind kind = 1;


    pub fn get_kind(&self) -> ExitReason_Error_Kind {
        self.kind
    }
    pub fn clear_kind(&mut self) {
        self.kind = ExitReason_Error_Kind::STACK_UNDERFLOW;
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ExitReason_Error_Kind) {
        self.kind = v;
    }

    // string error_string = 2;


    pub fn get_error_string(&self) -> &str {
        &self.error_string
    }
    pub fn clear_error_string(&mut self) {
        ::protobuf::Clear::clear(&mut self.error_string);
    }

    // Param is passed by value, moved
    pub fn set_error_string(&mut self, v: ::protobuf::Chars) {
        self.error_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_string(&mut self) -> &mut ::protobuf::Chars {
        &mut self.error_string
    }

    // Take field
    pub fn take_error_string(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.error_string, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ExitReason_Error {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.kind, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.error_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.kind != ExitReason_Error_Kind::STACK_UNDERFLOW {
            my_size += ::protobuf::rt::enum_size(1, self.kind);
        }
        if !self.error_string.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error_string);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.kind != ExitReason_Error_Kind::STACK_UNDERFLOW {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.kind))?;
        }
        if !self.error_string.is_empty() {
            os.write_string(2, &self.error_string)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExitReason_Error {
        ExitReason_Error::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ExitReason_Error_Kind>>(
                "kind",
                |m: &ExitReason_Error| { &m.kind },
                |m: &mut ExitReason_Error| { &mut m.kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                "error_string",
                |m: &ExitReason_Error| { &m.error_string },
                |m: &mut ExitReason_Error| { &mut m.error_string },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExitReason_Error>(
                "ExitReason.Error",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExitReason_Error {
        static instance: ::protobuf::rt::LazyV2<ExitReason_Error> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExitReason_Error::new)
    }
}

impl ::protobuf::Clear for ExitReason_Error {
    fn clear(&mut self) {
        self.kind = ExitReason_Error_Kind::STACK_UNDERFLOW;
        ::protobuf::Clear::clear(&mut self.error_string);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExitReason_Error {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExitReason_Error {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExitReason_Error_Kind {
    STACK_UNDERFLOW = 0,
    STACK_OVERFLOW = 1,
    INVALID_JUMP = 2,
    INVALID_RANGE = 3,
    DESIGNATED_INVALID = 4,
    CALL_TOO_DEEP = 5,
    CREATE_COLLISION = 6,
    CREATE_CONTRACT_LIMIT = 7,
    INVALID_CODE = 8,
    OUT_OF_OFFSET = 9,
    OUT_OF_GAS = 10,
    OUT_OF_FUND = 11,
    PC_UNDERFLOW = 12,
    CREATE_EMPTY = 13,
    OTHER = 14,
}

impl ::protobuf::ProtobufEnum for ExitReason_Error_Kind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExitReason_Error_Kind> {
        match value {
            0 => ::std::option::Option::Some(ExitReason_Error_Kind::STACK_UNDERFLOW),
            1 => ::std::option::Option::Some(ExitReason_Error_Kind::STACK_OVERFLOW),
            2 => ::std::option::Option::Some(ExitReason_Error_Kind::INVALID_JUMP),
            3 => ::std::option::Option::Some(ExitReason_Error_Kind::INVALID_RANGE),
            4 => ::std::option::Option::Some(ExitReason_Error_Kind::DESIGNATED_INVALID),
            5 => ::std::option::Option::Some(ExitReason_Error_Kind::CALL_TOO_DEEP),
            6 => ::std::option::Option::Some(ExitReason_Error_Kind::CREATE_COLLISION),
            7 => ::std::option::Option::Some(ExitReason_Error_Kind::CREATE_CONTRACT_LIMIT),
            8 => ::std::option::Option::Some(ExitReason_Error_Kind::INVALID_CODE),
            9 => ::std::option::Option::Some(ExitReason_Error_Kind::OUT_OF_OFFSET),
            10 => ::std::option::Option::Some(ExitReason_Error_Kind::OUT_OF_GAS),
            11 => ::std::option::Option::Some(ExitReason_Error_Kind::OUT_OF_FUND),
            12 => ::std::option::Option::Some(ExitReason_Error_Kind::PC_UNDERFLOW),
            13 => ::std::option::Option::Some(ExitReason_Error_Kind::CREATE_EMPTY),
            14 => ::std::option::Option::Some(ExitReason_Error_Kind::OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExitReason_Error_Kind] = &[
            ExitReason_Error_Kind::STACK_UNDERFLOW,
            ExitReason_Error_Kind::STACK_OVERFLOW,
            ExitReason_Error_Kind::INVALID_JUMP,
            ExitReason_Error_Kind::INVALID_RANGE,
            ExitReason_Error_Kind::DESIGNATED_INVALID,
            ExitReason_Error_Kind::CALL_TOO_DEEP,
            ExitReason_Error_Kind::CREATE_COLLISION,
            ExitReason_Error_Kind::CREATE_CONTRACT_LIMIT,
            ExitReason_Error_Kind::INVALID_CODE,
            ExitReason_Error_Kind::OUT_OF_OFFSET,
            ExitReason_Error_Kind::OUT_OF_GAS,
            ExitReason_Error_Kind::OUT_OF_FUND,
            ExitReason_Error_Kind::PC_UNDERFLOW,
            ExitReason_Error_Kind::CREATE_EMPTY,
            ExitReason_Error_Kind::OTHER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ExitReason_Error_Kind>("ExitReason.Error.Kind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ExitReason_Error_Kind {
}

impl ::std::default::Default for ExitReason_Error_Kind {
    fn default() -> Self {
        ExitReason_Error_Kind::STACK_UNDERFLOW
    }
}

impl ::protobuf::reflect::ProtobufValue for ExitReason_Error_Kind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExitReason_Fatal {
    // message fields
    pub kind: ExitReason_Fatal_Kind,
    pub error: ::protobuf::SingularPtrField<ExitReason_Error>,
    pub error_string: ::protobuf::Chars,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExitReason_Fatal {
    fn default() -> &'a ExitReason_Fatal {
        <ExitReason_Fatal as ::protobuf::Message>::default_instance()
    }
}

impl ExitReason_Fatal {
    pub fn new() -> ExitReason_Fatal {
        ::std::default::Default::default()
    }

    // .evm.ExitReason.Fatal.Kind kind = 1;


    pub fn get_kind(&self) -> ExitReason_Fatal_Kind {
        self.kind
    }
    pub fn clear_kind(&mut self) {
        self.kind = ExitReason_Fatal_Kind::NOT_SUPPORTED;
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ExitReason_Fatal_Kind) {
        self.kind = v;
    }

    // .evm.ExitReason.Error error = 2;


    pub fn get_error(&self) -> &ExitReason_Error {
        self.error.as_ref().unwrap_or_else(|| <ExitReason_Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ExitReason_Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ExitReason_Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ExitReason_Error {
        self.error.take().unwrap_or_else(|| ExitReason_Error::new())
    }

    // string error_string = 3;


    pub fn get_error_string(&self) -> &str {
        &self.error_string
    }
    pub fn clear_error_string(&mut self) {
        ::protobuf::Clear::clear(&mut self.error_string);
    }

    // Param is passed by value, moved
    pub fn set_error_string(&mut self, v: ::protobuf::Chars) {
        self.error_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_string(&mut self) -> &mut ::protobuf::Chars {
        &mut self.error_string
    }

    // Take field
    pub fn take_error_string(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.error_string, ::protobuf::Chars::new())
    }
}

impl ::protobuf::Message for ExitReason_Fatal {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.kind, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.error_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.kind != ExitReason_Fatal_Kind::NOT_SUPPORTED {
            my_size += ::protobuf::rt::enum_size(1, self.kind);
        }
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error_string.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.error_string);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.kind != ExitReason_Fatal_Kind::NOT_SUPPORTED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.kind))?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error_string.is_empty() {
            os.write_string(3, &self.error_string)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExitReason_Fatal {
        ExitReason_Fatal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ExitReason_Fatal_Kind>>(
                "kind",
                |m: &ExitReason_Fatal| { &m.kind },
                |m: &mut ExitReason_Fatal| { &mut m.kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExitReason_Error>>(
                "error",
                |m: &ExitReason_Fatal| { &m.error },
                |m: &mut ExitReason_Fatal| { &mut m.error },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                "error_string",
                |m: &ExitReason_Fatal| { &m.error_string },
                |m: &mut ExitReason_Fatal| { &mut m.error_string },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExitReason_Fatal>(
                "ExitReason.Fatal",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExitReason_Fatal {
        static instance: ::protobuf::rt::LazyV2<ExitReason_Fatal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExitReason_Fatal::new)
    }
}

impl ::protobuf::Clear for ExitReason_Fatal {
    fn clear(&mut self) {
        self.kind = ExitReason_Fatal_Kind::NOT_SUPPORTED;
        self.error.clear();
        ::protobuf::Clear::clear(&mut self.error_string);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExitReason_Fatal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExitReason_Fatal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExitReason_Fatal_Kind {
    NOT_SUPPORTED = 0,
    UNHANDLED_INTERRUPT = 1,
    CALL_ERROR_AS_FATAL = 2,
    OTHER = 3,
}

impl ::protobuf::ProtobufEnum for ExitReason_Fatal_Kind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExitReason_Fatal_Kind> {
        match value {
            0 => ::std::option::Option::Some(ExitReason_Fatal_Kind::NOT_SUPPORTED),
            1 => ::std::option::Option::Some(ExitReason_Fatal_Kind::UNHANDLED_INTERRUPT),
            2 => ::std::option::Option::Some(ExitReason_Fatal_Kind::CALL_ERROR_AS_FATAL),
            3 => ::std::option::Option::Some(ExitReason_Fatal_Kind::OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExitReason_Fatal_Kind] = &[
            ExitReason_Fatal_Kind::NOT_SUPPORTED,
            ExitReason_Fatal_Kind::UNHANDLED_INTERRUPT,
            ExitReason_Fatal_Kind::CALL_ERROR_AS_FATAL,
            ExitReason_Fatal_Kind::OTHER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ExitReason_Fatal_Kind>("ExitReason.Fatal.Kind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ExitReason_Fatal_Kind {
}

impl ::std::default::Default for ExitReason_Fatal_Kind {
    fn default() -> Self {
        ExitReason_Fatal_Kind::NOT_SUPPORTED
    }
}

impl ::protobuf::reflect::ProtobufValue for ExitReason_Fatal_Kind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExitReason_Trap {
    // message fields
    pub kind: ExitReason_Trap_Kind,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExitReason_Trap {
    fn default() -> &'a ExitReason_Trap {
        <ExitReason_Trap as ::protobuf::Message>::default_instance()
    }
}

impl ExitReason_Trap {
    pub fn new() -> ExitReason_Trap {
        ::std::default::Default::default()
    }

    // .evm.ExitReason.Trap.Kind kind = 1;


    pub fn get_kind(&self) -> ExitReason_Trap_Kind {
        self.kind
    }
    pub fn clear_kind(&mut self) {
        self.kind = ExitReason_Trap_Kind::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ExitReason_Trap_Kind) {
        self.kind = v;
    }
}

impl ::protobuf::Message for ExitReason_Trap {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.kind, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.kind != ExitReason_Trap_Kind::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.kind);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.kind != ExitReason_Trap_Kind::UNKNOWN {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.kind))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExitReason_Trap {
        ExitReason_Trap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ExitReason_Trap_Kind>>(
                "kind",
                |m: &ExitReason_Trap| { &m.kind },
                |m: &mut ExitReason_Trap| { &mut m.kind },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExitReason_Trap>(
                "ExitReason.Trap",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExitReason_Trap {
        static instance: ::protobuf::rt::LazyV2<ExitReason_Trap> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExitReason_Trap::new)
    }
}

impl ::protobuf::Clear for ExitReason_Trap {
    fn clear(&mut self) {
        self.kind = ExitReason_Trap_Kind::UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExitReason_Trap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExitReason_Trap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExitReason_Trap_Kind {
    UNKNOWN = 0,
    CALL = 1,
    CREATE = 2,
}

impl ::protobuf::ProtobufEnum for ExitReason_Trap_Kind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExitReason_Trap_Kind> {
        match value {
            0 => ::std::option::Option::Some(ExitReason_Trap_Kind::UNKNOWN),
            1 => ::std::option::Option::Some(ExitReason_Trap_Kind::CALL),
            2 => ::std::option::Option::Some(ExitReason_Trap_Kind::CREATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExitReason_Trap_Kind] = &[
            ExitReason_Trap_Kind::UNKNOWN,
            ExitReason_Trap_Kind::CALL,
            ExitReason_Trap_Kind::CREATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ExitReason_Trap_Kind>("ExitReason.Trap.Kind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ExitReason_Trap_Kind {
}

impl ::std::default::Default for ExitReason_Trap_Kind {
    fn default() -> Self {
        ExitReason_Trap_Kind::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for ExitReason_Trap_Kind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExitReason_Succeed {
    STOPPED = 0,
    RETURNED = 1,
    SUICIDED = 2,
}

impl ::protobuf::ProtobufEnum for ExitReason_Succeed {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExitReason_Succeed> {
        match value {
            0 => ::std::option::Option::Some(ExitReason_Succeed::STOPPED),
            1 => ::std::option::Option::Some(ExitReason_Succeed::RETURNED),
            2 => ::std::option::Option::Some(ExitReason_Succeed::SUICIDED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExitReason_Succeed] = &[
            ExitReason_Succeed::STOPPED,
            ExitReason_Succeed::RETURNED,
            ExitReason_Succeed::SUICIDED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ExitReason_Succeed>("ExitReason.Succeed", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ExitReason_Succeed {
}

impl ::std::default::Default for ExitReason_Succeed {
    fn default() -> Self {
        ExitReason_Succeed::STOPPED
    }
}

impl ::protobuf::reflect::ProtobufValue for ExitReason_Succeed {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExitReason_Revert {
    REVERTED = 0,
}

impl ::protobuf::ProtobufEnum for ExitReason_Revert {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExitReason_Revert> {
        match value {
            0 => ::std::option::Option::Some(ExitReason_Revert::REVERTED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExitReason_Revert] = &[
            ExitReason_Revert::REVERTED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ExitReason_Revert>("ExitReason.Revert", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ExitReason_Revert {
}

impl ::std::default::Default for ExitReason_Revert {
    fn default() -> Self {
        ExitReason_Revert::REVERTED
    }
}

impl ::protobuf::reflect::ProtobufValue for ExitReason_Revert {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrapData {
    // message oneof groups
    pub data: ::std::option::Option<TrapData_oneof_data>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrapData {
    fn default() -> &'a TrapData {
        <TrapData as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TrapData_oneof_data {
    call(TrapData_Call),
    create(TrapData_Create),
}

impl TrapData {
    pub fn new() -> TrapData {
        ::std::default::Default::default()
    }

    // .evm.TrapData.Call call = 1;


    pub fn get_call(&self) -> &TrapData_Call {
        match self.data {
            ::std::option::Option::Some(TrapData_oneof_data::call(ref v)) => v,
            _ => <TrapData_Call as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_call(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_call(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(TrapData_oneof_data::call(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_call(&mut self, v: TrapData_Call) {
        self.data = ::std::option::Option::Some(TrapData_oneof_data::call(v))
    }

    // Mutable pointer to the field.
    pub fn mut_call(&mut self) -> &mut TrapData_Call {
        if let ::std::option::Option::Some(TrapData_oneof_data::call(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(TrapData_oneof_data::call(TrapData_Call::new()));
        }
        match self.data {
            ::std::option::Option::Some(TrapData_oneof_data::call(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_call(&mut self) -> TrapData_Call {
        if self.has_call() {
            match self.data.take() {
                ::std::option::Option::Some(TrapData_oneof_data::call(v)) => v,
                _ => panic!(),
            }
        } else {
            TrapData_Call::new()
        }
    }

    // .evm.TrapData.Create create = 2;


    pub fn get_create(&self) -> &TrapData_Create {
        match self.data {
            ::std::option::Option::Some(TrapData_oneof_data::create(ref v)) => v,
            _ => <TrapData_Create as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_create(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_create(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(TrapData_oneof_data::create(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create(&mut self, v: TrapData_Create) {
        self.data = ::std::option::Option::Some(TrapData_oneof_data::create(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create(&mut self) -> &mut TrapData_Create {
        if let ::std::option::Option::Some(TrapData_oneof_data::create(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(TrapData_oneof_data::create(TrapData_Create::new()));
        }
        match self.data {
            ::std::option::Option::Some(TrapData_oneof_data::create(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create(&mut self) -> TrapData_Create {
        if self.has_create() {
            match self.data.take() {
                ::std::option::Option::Some(TrapData_oneof_data::create(v)) => v,
                _ => panic!(),
            }
        } else {
            TrapData_Create::new()
        }
    }
}

impl ::protobuf::Message for TrapData {
    fn is_initialized(&self) -> bool {
        if let Some(TrapData_oneof_data::call(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TrapData_oneof_data::create(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(TrapData_oneof_data::call(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(TrapData_oneof_data::create(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &TrapData_oneof_data::call(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TrapData_oneof_data::create(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &TrapData_oneof_data::call(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TrapData_oneof_data::create(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrapData {
        TrapData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TrapData_Call>(
                "call",
                TrapData::has_call,
                TrapData::get_call,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TrapData_Create>(
                "create",
                TrapData::has_create,
                TrapData::get_create,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrapData>(
                "TrapData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrapData {
        static instance: ::protobuf::rt::LazyV2<TrapData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrapData::new)
    }
}

impl ::protobuf::Clear for TrapData {
    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrapData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrapData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrapData_Transfer {
    // message fields
    pub source: ::protobuf::SingularPtrField<Address>,
    pub destination: ::protobuf::SingularPtrField<Address>,
    pub value: ::protobuf::SingularPtrField<UInt256>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrapData_Transfer {
    fn default() -> &'a TrapData_Transfer {
        <TrapData_Transfer as ::protobuf::Message>::default_instance()
    }
}

impl TrapData_Transfer {
    pub fn new() -> TrapData_Transfer {
        ::std::default::Default::default()
    }

    // .evm.Address source = 1;


    pub fn get_source(&self) -> &Address {
        self.source.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Address) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut Address {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Address {
        self.source.take().unwrap_or_else(|| Address::new())
    }

    // .evm.Address destination = 2;


    pub fn get_destination(&self) -> &Address {
        self.destination.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    pub fn has_destination(&self) -> bool {
        self.destination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: Address) {
        self.destination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut Address {
        if self.destination.is_none() {
            self.destination.set_default();
        }
        self.destination.as_mut().unwrap()
    }

    // Take field
    pub fn take_destination(&mut self) -> Address {
        self.destination.take().unwrap_or_else(|| Address::new())
    }

    // .evm.UInt256 value = 3;


    pub fn get_value(&self) -> &UInt256 {
        self.value.as_ref().unwrap_or_else(|| <UInt256 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: UInt256) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut UInt256 {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> UInt256 {
        self.value.take().unwrap_or_else(|| UInt256::new())
    }
}

impl ::protobuf::Message for TrapData_Transfer {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.destination {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.destination)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.destination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.destination.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrapData_Transfer {
        TrapData_Transfer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "source",
                |m: &TrapData_Transfer| { &m.source },
                |m: &mut TrapData_Transfer| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "destination",
                |m: &TrapData_Transfer| { &m.destination },
                |m: &mut TrapData_Transfer| { &mut m.destination },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UInt256>>(
                "value",
                |m: &TrapData_Transfer| { &m.value },
                |m: &mut TrapData_Transfer| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrapData_Transfer>(
                "TrapData.Transfer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrapData_Transfer {
        static instance: ::protobuf::rt::LazyV2<TrapData_Transfer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrapData_Transfer::new)
    }
}

impl ::protobuf::Clear for TrapData_Transfer {
    fn clear(&mut self) {
        self.source.clear();
        self.destination.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrapData_Transfer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrapData_Transfer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrapData_Context {
    // message fields
    pub destination: ::protobuf::SingularPtrField<Address>,
    pub caller: ::protobuf::SingularPtrField<Address>,
    pub apparent_value: ::protobuf::SingularPtrField<UInt256>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrapData_Context {
    fn default() -> &'a TrapData_Context {
        <TrapData_Context as ::protobuf::Message>::default_instance()
    }
}

impl TrapData_Context {
    pub fn new() -> TrapData_Context {
        ::std::default::Default::default()
    }

    // .evm.Address destination = 1;


    pub fn get_destination(&self) -> &Address {
        self.destination.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    pub fn has_destination(&self) -> bool {
        self.destination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: Address) {
        self.destination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut Address {
        if self.destination.is_none() {
            self.destination.set_default();
        }
        self.destination.as_mut().unwrap()
    }

    // Take field
    pub fn take_destination(&mut self) -> Address {
        self.destination.take().unwrap_or_else(|| Address::new())
    }

    // .evm.Address caller = 2;


    pub fn get_caller(&self) -> &Address {
        self.caller.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_caller(&mut self) {
        self.caller.clear();
    }

    pub fn has_caller(&self) -> bool {
        self.caller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller(&mut self, v: Address) {
        self.caller = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caller(&mut self) -> &mut Address {
        if self.caller.is_none() {
            self.caller.set_default();
        }
        self.caller.as_mut().unwrap()
    }

    // Take field
    pub fn take_caller(&mut self) -> Address {
        self.caller.take().unwrap_or_else(|| Address::new())
    }

    // .evm.UInt256 apparent_value = 3;


    pub fn get_apparent_value(&self) -> &UInt256 {
        self.apparent_value.as_ref().unwrap_or_else(|| <UInt256 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_apparent_value(&mut self) {
        self.apparent_value.clear();
    }

    pub fn has_apparent_value(&self) -> bool {
        self.apparent_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apparent_value(&mut self, v: UInt256) {
        self.apparent_value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apparent_value(&mut self) -> &mut UInt256 {
        if self.apparent_value.is_none() {
            self.apparent_value.set_default();
        }
        self.apparent_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_apparent_value(&mut self) -> UInt256 {
        self.apparent_value.take().unwrap_or_else(|| UInt256::new())
    }
}

impl ::protobuf::Message for TrapData_Context {
    fn is_initialized(&self) -> bool {
        for v in &self.destination {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.caller {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apparent_value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.destination)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.caller)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.apparent_value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.destination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.caller.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.apparent_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.destination.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.caller.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.apparent_value.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrapData_Context {
        TrapData_Context::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "destination",
                |m: &TrapData_Context| { &m.destination },
                |m: &mut TrapData_Context| { &mut m.destination },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "caller",
                |m: &TrapData_Context| { &m.caller },
                |m: &mut TrapData_Context| { &mut m.caller },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UInt256>>(
                "apparent_value",
                |m: &TrapData_Context| { &m.apparent_value },
                |m: &mut TrapData_Context| { &mut m.apparent_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrapData_Context>(
                "TrapData.Context",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrapData_Context {
        static instance: ::protobuf::rt::LazyV2<TrapData_Context> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrapData_Context::new)
    }
}

impl ::protobuf::Clear for TrapData_Context {
    fn clear(&mut self) {
        self.destination.clear();
        self.caller.clear();
        self.apparent_value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrapData_Context {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrapData_Context {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrapData_Scheme {
    // message oneof groups
    pub field_type: ::std::option::Option<TrapData_Scheme_oneof_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrapData_Scheme {
    fn default() -> &'a TrapData_Scheme {
        <TrapData_Scheme as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TrapData_Scheme_oneof_type {
    legacy(TrapData_Scheme_Legacy),
    create2(TrapData_Scheme_Create2),
    fixed(TrapData_Scheme_Fixed),
}

impl TrapData_Scheme {
    pub fn new() -> TrapData_Scheme {
        ::std::default::Default::default()
    }

    // .evm.TrapData.Scheme.Legacy legacy = 1;


    pub fn get_legacy(&self) -> &TrapData_Scheme_Legacy {
        match self.field_type {
            ::std::option::Option::Some(TrapData_Scheme_oneof_type::legacy(ref v)) => v,
            _ => <TrapData_Scheme_Legacy as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_legacy(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_legacy(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(TrapData_Scheme_oneof_type::legacy(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_legacy(&mut self, v: TrapData_Scheme_Legacy) {
        self.field_type = ::std::option::Option::Some(TrapData_Scheme_oneof_type::legacy(v))
    }

    // Mutable pointer to the field.
    pub fn mut_legacy(&mut self) -> &mut TrapData_Scheme_Legacy {
        if let ::std::option::Option::Some(TrapData_Scheme_oneof_type::legacy(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(TrapData_Scheme_oneof_type::legacy(TrapData_Scheme_Legacy::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(TrapData_Scheme_oneof_type::legacy(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_legacy(&mut self) -> TrapData_Scheme_Legacy {
        if self.has_legacy() {
            match self.field_type.take() {
                ::std::option::Option::Some(TrapData_Scheme_oneof_type::legacy(v)) => v,
                _ => panic!(),
            }
        } else {
            TrapData_Scheme_Legacy::new()
        }
    }

    // .evm.TrapData.Scheme.Create2 create2 = 2;


    pub fn get_create2(&self) -> &TrapData_Scheme_Create2 {
        match self.field_type {
            ::std::option::Option::Some(TrapData_Scheme_oneof_type::create2(ref v)) => v,
            _ => <TrapData_Scheme_Create2 as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_create2(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_create2(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(TrapData_Scheme_oneof_type::create2(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create2(&mut self, v: TrapData_Scheme_Create2) {
        self.field_type = ::std::option::Option::Some(TrapData_Scheme_oneof_type::create2(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create2(&mut self) -> &mut TrapData_Scheme_Create2 {
        if let ::std::option::Option::Some(TrapData_Scheme_oneof_type::create2(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(TrapData_Scheme_oneof_type::create2(TrapData_Scheme_Create2::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(TrapData_Scheme_oneof_type::create2(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create2(&mut self) -> TrapData_Scheme_Create2 {
        if self.has_create2() {
            match self.field_type.take() {
                ::std::option::Option::Some(TrapData_Scheme_oneof_type::create2(v)) => v,
                _ => panic!(),
            }
        } else {
            TrapData_Scheme_Create2::new()
        }
    }

    // .evm.TrapData.Scheme.Fixed fixed = 3;


    pub fn get_fixed(&self) -> &TrapData_Scheme_Fixed {
        match self.field_type {
            ::std::option::Option::Some(TrapData_Scheme_oneof_type::fixed(ref v)) => v,
            _ => <TrapData_Scheme_Fixed as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_fixed(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_fixed(&self) -> bool {
        match self.field_type {
            ::std::option::Option::Some(TrapData_Scheme_oneof_type::fixed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fixed(&mut self, v: TrapData_Scheme_Fixed) {
        self.field_type = ::std::option::Option::Some(TrapData_Scheme_oneof_type::fixed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fixed(&mut self) -> &mut TrapData_Scheme_Fixed {
        if let ::std::option::Option::Some(TrapData_Scheme_oneof_type::fixed(_)) = self.field_type {
        } else {
            self.field_type = ::std::option::Option::Some(TrapData_Scheme_oneof_type::fixed(TrapData_Scheme_Fixed::new()));
        }
        match self.field_type {
            ::std::option::Option::Some(TrapData_Scheme_oneof_type::fixed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fixed(&mut self) -> TrapData_Scheme_Fixed {
        if self.has_fixed() {
            match self.field_type.take() {
                ::std::option::Option::Some(TrapData_Scheme_oneof_type::fixed(v)) => v,
                _ => panic!(),
            }
        } else {
            TrapData_Scheme_Fixed::new()
        }
    }
}

impl ::protobuf::Message for TrapData_Scheme {
    fn is_initialized(&self) -> bool {
        if let Some(TrapData_Scheme_oneof_type::legacy(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TrapData_Scheme_oneof_type::create2(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TrapData_Scheme_oneof_type::fixed(ref v)) = self.field_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(TrapData_Scheme_oneof_type::legacy(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(TrapData_Scheme_oneof_type::create2(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(TrapData_Scheme_oneof_type::fixed(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &TrapData_Scheme_oneof_type::legacy(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TrapData_Scheme_oneof_type::create2(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TrapData_Scheme_oneof_type::fixed(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.field_type {
            match v {
                &TrapData_Scheme_oneof_type::legacy(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TrapData_Scheme_oneof_type::create2(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TrapData_Scheme_oneof_type::fixed(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrapData_Scheme {
        TrapData_Scheme::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TrapData_Scheme_Legacy>(
                "legacy",
                TrapData_Scheme::has_legacy,
                TrapData_Scheme::get_legacy,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TrapData_Scheme_Create2>(
                "create2",
                TrapData_Scheme::has_create2,
                TrapData_Scheme::get_create2,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TrapData_Scheme_Fixed>(
                "fixed",
                TrapData_Scheme::has_fixed,
                TrapData_Scheme::get_fixed,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrapData_Scheme>(
                "TrapData.Scheme",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrapData_Scheme {
        static instance: ::protobuf::rt::LazyV2<TrapData_Scheme> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrapData_Scheme::new)
    }
}

impl ::protobuf::Clear for TrapData_Scheme {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrapData_Scheme {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrapData_Scheme {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrapData_Scheme_Legacy {
    // message fields
    pub caller: ::protobuf::SingularPtrField<Address>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrapData_Scheme_Legacy {
    fn default() -> &'a TrapData_Scheme_Legacy {
        <TrapData_Scheme_Legacy as ::protobuf::Message>::default_instance()
    }
}

impl TrapData_Scheme_Legacy {
    pub fn new() -> TrapData_Scheme_Legacy {
        ::std::default::Default::default()
    }

    // .evm.Address caller = 1;


    pub fn get_caller(&self) -> &Address {
        self.caller.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_caller(&mut self) {
        self.caller.clear();
    }

    pub fn has_caller(&self) -> bool {
        self.caller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller(&mut self, v: Address) {
        self.caller = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caller(&mut self) -> &mut Address {
        if self.caller.is_none() {
            self.caller.set_default();
        }
        self.caller.as_mut().unwrap()
    }

    // Take field
    pub fn take_caller(&mut self) -> Address {
        self.caller.take().unwrap_or_else(|| Address::new())
    }
}

impl ::protobuf::Message for TrapData_Scheme_Legacy {
    fn is_initialized(&self) -> bool {
        for v in &self.caller {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.caller)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.caller.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.caller.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrapData_Scheme_Legacy {
        TrapData_Scheme_Legacy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "caller",
                |m: &TrapData_Scheme_Legacy| { &m.caller },
                |m: &mut TrapData_Scheme_Legacy| { &mut m.caller },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrapData_Scheme_Legacy>(
                "TrapData.Scheme.Legacy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrapData_Scheme_Legacy {
        static instance: ::protobuf::rt::LazyV2<TrapData_Scheme_Legacy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrapData_Scheme_Legacy::new)
    }
}

impl ::protobuf::Clear for TrapData_Scheme_Legacy {
    fn clear(&mut self) {
        self.caller.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrapData_Scheme_Legacy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrapData_Scheme_Legacy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrapData_Scheme_Create2 {
    // message fields
    pub caller: ::protobuf::SingularPtrField<Address>,
    pub code_hash: ::protobuf::SingularPtrField<H256>,
    pub salt: ::protobuf::SingularPtrField<H256>,
    pub create2_address: ::protobuf::SingularPtrField<Address>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrapData_Scheme_Create2 {
    fn default() -> &'a TrapData_Scheme_Create2 {
        <TrapData_Scheme_Create2 as ::protobuf::Message>::default_instance()
    }
}

impl TrapData_Scheme_Create2 {
    pub fn new() -> TrapData_Scheme_Create2 {
        ::std::default::Default::default()
    }

    // .evm.Address caller = 1;


    pub fn get_caller(&self) -> &Address {
        self.caller.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_caller(&mut self) {
        self.caller.clear();
    }

    pub fn has_caller(&self) -> bool {
        self.caller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller(&mut self, v: Address) {
        self.caller = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caller(&mut self) -> &mut Address {
        if self.caller.is_none() {
            self.caller.set_default();
        }
        self.caller.as_mut().unwrap()
    }

    // Take field
    pub fn take_caller(&mut self) -> Address {
        self.caller.take().unwrap_or_else(|| Address::new())
    }

    // .evm.H256 code_hash = 2;


    pub fn get_code_hash(&self) -> &H256 {
        self.code_hash.as_ref().unwrap_or_else(|| <H256 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_code_hash(&mut self) {
        self.code_hash.clear();
    }

    pub fn has_code_hash(&self) -> bool {
        self.code_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code_hash(&mut self, v: H256) {
        self.code_hash = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code_hash(&mut self) -> &mut H256 {
        if self.code_hash.is_none() {
            self.code_hash.set_default();
        }
        self.code_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_code_hash(&mut self) -> H256 {
        self.code_hash.take().unwrap_or_else(|| H256::new())
    }

    // .evm.H256 salt = 3;


    pub fn get_salt(&self) -> &H256 {
        self.salt.as_ref().unwrap_or_else(|| <H256 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_salt(&mut self) {
        self.salt.clear();
    }

    pub fn has_salt(&self) -> bool {
        self.salt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_salt(&mut self, v: H256) {
        self.salt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_salt(&mut self) -> &mut H256 {
        if self.salt.is_none() {
            self.salt.set_default();
        }
        self.salt.as_mut().unwrap()
    }

    // Take field
    pub fn take_salt(&mut self) -> H256 {
        self.salt.take().unwrap_or_else(|| H256::new())
    }

    // .evm.Address create2_address = 4;


    pub fn get_create2_address(&self) -> &Address {
        self.create2_address.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create2_address(&mut self) {
        self.create2_address.clear();
    }

    pub fn has_create2_address(&self) -> bool {
        self.create2_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create2_address(&mut self, v: Address) {
        self.create2_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create2_address(&mut self) -> &mut Address {
        if self.create2_address.is_none() {
            self.create2_address.set_default();
        }
        self.create2_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_create2_address(&mut self) -> Address {
        self.create2_address.take().unwrap_or_else(|| Address::new())
    }
}

impl ::protobuf::Message for TrapData_Scheme_Create2 {
    fn is_initialized(&self) -> bool {
        for v in &self.caller {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.code_hash {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.salt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create2_address {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.caller)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.code_hash)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.salt)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create2_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.caller.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.code_hash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.salt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.create2_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.caller.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.code_hash.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.salt.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.create2_address.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrapData_Scheme_Create2 {
        TrapData_Scheme_Create2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "caller",
                |m: &TrapData_Scheme_Create2| { &m.caller },
                |m: &mut TrapData_Scheme_Create2| { &mut m.caller },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<H256>>(
                "code_hash",
                |m: &TrapData_Scheme_Create2| { &m.code_hash },
                |m: &mut TrapData_Scheme_Create2| { &mut m.code_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<H256>>(
                "salt",
                |m: &TrapData_Scheme_Create2| { &m.salt },
                |m: &mut TrapData_Scheme_Create2| { &mut m.salt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "create2_address",
                |m: &TrapData_Scheme_Create2| { &m.create2_address },
                |m: &mut TrapData_Scheme_Create2| { &mut m.create2_address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrapData_Scheme_Create2>(
                "TrapData.Scheme.Create2",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrapData_Scheme_Create2 {
        static instance: ::protobuf::rt::LazyV2<TrapData_Scheme_Create2> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrapData_Scheme_Create2::new)
    }
}

impl ::protobuf::Clear for TrapData_Scheme_Create2 {
    fn clear(&mut self) {
        self.caller.clear();
        self.code_hash.clear();
        self.salt.clear();
        self.create2_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrapData_Scheme_Create2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrapData_Scheme_Create2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrapData_Scheme_Fixed {
    // message fields
    pub addres: ::protobuf::SingularPtrField<Address>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrapData_Scheme_Fixed {
    fn default() -> &'a TrapData_Scheme_Fixed {
        <TrapData_Scheme_Fixed as ::protobuf::Message>::default_instance()
    }
}

impl TrapData_Scheme_Fixed {
    pub fn new() -> TrapData_Scheme_Fixed {
        ::std::default::Default::default()
    }

    // .evm.Address addres = 1;


    pub fn get_addres(&self) -> &Address {
        self.addres.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_addres(&mut self) {
        self.addres.clear();
    }

    pub fn has_addres(&self) -> bool {
        self.addres.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addres(&mut self, v: Address) {
        self.addres = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addres(&mut self) -> &mut Address {
        if self.addres.is_none() {
            self.addres.set_default();
        }
        self.addres.as_mut().unwrap()
    }

    // Take field
    pub fn take_addres(&mut self) -> Address {
        self.addres.take().unwrap_or_else(|| Address::new())
    }
}

impl ::protobuf::Message for TrapData_Scheme_Fixed {
    fn is_initialized(&self) -> bool {
        for v in &self.addres {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addres)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.addres.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.addres.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrapData_Scheme_Fixed {
        TrapData_Scheme_Fixed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "addres",
                |m: &TrapData_Scheme_Fixed| { &m.addres },
                |m: &mut TrapData_Scheme_Fixed| { &mut m.addres },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrapData_Scheme_Fixed>(
                "TrapData.Scheme.Fixed",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrapData_Scheme_Fixed {
        static instance: ::protobuf::rt::LazyV2<TrapData_Scheme_Fixed> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrapData_Scheme_Fixed::new)
    }
}

impl ::protobuf::Clear for TrapData_Scheme_Fixed {
    fn clear(&mut self) {
        self.addres.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrapData_Scheme_Fixed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrapData_Scheme_Fixed {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrapData_Call {
    // message fields
    pub callee_address: ::protobuf::SingularPtrField<Address>,
    pub transfer: ::protobuf::SingularPtrField<TrapData_Transfer>,
    pub call_data: ::bytes::Bytes,
    pub target_gas: u64,
    pub is_static: bool,
    pub context: ::protobuf::SingularPtrField<TrapData_Context>,
    pub memory_offset: ::protobuf::SingularPtrField<UInt256>,
    pub offset_len: ::protobuf::SingularPtrField<UInt256>,
    pub is_precompile: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrapData_Call {
    fn default() -> &'a TrapData_Call {
        <TrapData_Call as ::protobuf::Message>::default_instance()
    }
}

impl TrapData_Call {
    pub fn new() -> TrapData_Call {
        ::std::default::Default::default()
    }

    // .evm.Address callee_address = 1;


    pub fn get_callee_address(&self) -> &Address {
        self.callee_address.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_callee_address(&mut self) {
        self.callee_address.clear();
    }

    pub fn has_callee_address(&self) -> bool {
        self.callee_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_callee_address(&mut self, v: Address) {
        self.callee_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_callee_address(&mut self) -> &mut Address {
        if self.callee_address.is_none() {
            self.callee_address.set_default();
        }
        self.callee_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_callee_address(&mut self) -> Address {
        self.callee_address.take().unwrap_or_else(|| Address::new())
    }

    // .evm.TrapData.Transfer transfer = 2;


    pub fn get_transfer(&self) -> &TrapData_Transfer {
        self.transfer.as_ref().unwrap_or_else(|| <TrapData_Transfer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_transfer(&mut self) {
        self.transfer.clear();
    }

    pub fn has_transfer(&self) -> bool {
        self.transfer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transfer(&mut self, v: TrapData_Transfer) {
        self.transfer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transfer(&mut self) -> &mut TrapData_Transfer {
        if self.transfer.is_none() {
            self.transfer.set_default();
        }
        self.transfer.as_mut().unwrap()
    }

    // Take field
    pub fn take_transfer(&mut self) -> TrapData_Transfer {
        self.transfer.take().unwrap_or_else(|| TrapData_Transfer::new())
    }

    // bytes call_data = 3;


    pub fn get_call_data(&self) -> &[u8] {
        &self.call_data
    }
    pub fn clear_call_data(&mut self) {
        self.call_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_call_data(&mut self, v: ::bytes::Bytes) {
        self.call_data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_call_data(&mut self) -> &mut ::bytes::Bytes {
        &mut self.call_data
    }

    // Take field
    pub fn take_call_data(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.call_data, ::bytes::Bytes::new())
    }

    // uint64 target_gas = 4;


    pub fn get_target_gas(&self) -> u64 {
        self.target_gas
    }
    pub fn clear_target_gas(&mut self) {
        self.target_gas = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_gas(&mut self, v: u64) {
        self.target_gas = v;
    }

    // bool is_static = 5;


    pub fn get_is_static(&self) -> bool {
        self.is_static
    }
    pub fn clear_is_static(&mut self) {
        self.is_static = false;
    }

    // Param is passed by value, moved
    pub fn set_is_static(&mut self, v: bool) {
        self.is_static = v;
    }

    // .evm.TrapData.Context context = 6;


    pub fn get_context(&self) -> &TrapData_Context {
        self.context.as_ref().unwrap_or_else(|| <TrapData_Context as ::protobuf::Message>::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: TrapData_Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut TrapData_Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> TrapData_Context {
        self.context.take().unwrap_or_else(|| TrapData_Context::new())
    }

    // .evm.UInt256 memory_offset = 7;


    pub fn get_memory_offset(&self) -> &UInt256 {
        self.memory_offset.as_ref().unwrap_or_else(|| <UInt256 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_memory_offset(&mut self) {
        self.memory_offset.clear();
    }

    pub fn has_memory_offset(&self) -> bool {
        self.memory_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memory_offset(&mut self, v: UInt256) {
        self.memory_offset = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_memory_offset(&mut self) -> &mut UInt256 {
        if self.memory_offset.is_none() {
            self.memory_offset.set_default();
        }
        self.memory_offset.as_mut().unwrap()
    }

    // Take field
    pub fn take_memory_offset(&mut self) -> UInt256 {
        self.memory_offset.take().unwrap_or_else(|| UInt256::new())
    }

    // .evm.UInt256 offset_len = 8;


    pub fn get_offset_len(&self) -> &UInt256 {
        self.offset_len.as_ref().unwrap_or_else(|| <UInt256 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_offset_len(&mut self) {
        self.offset_len.clear();
    }

    pub fn has_offset_len(&self) -> bool {
        self.offset_len.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset_len(&mut self, v: UInt256) {
        self.offset_len = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offset_len(&mut self) -> &mut UInt256 {
        if self.offset_len.is_none() {
            self.offset_len.set_default();
        }
        self.offset_len.as_mut().unwrap()
    }

    // Take field
    pub fn take_offset_len(&mut self) -> UInt256 {
        self.offset_len.take().unwrap_or_else(|| UInt256::new())
    }

    // bool is_precompile = 9;


    pub fn get_is_precompile(&self) -> bool {
        self.is_precompile
    }
    pub fn clear_is_precompile(&mut self) {
        self.is_precompile = false;
    }

    // Param is passed by value, moved
    pub fn set_is_precompile(&mut self, v: bool) {
        self.is_precompile = v;
    }
}

impl ::protobuf::Message for TrapData_Call {
    fn is_initialized(&self) -> bool {
        for v in &self.callee_address {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transfer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.memory_offset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.offset_len {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.callee_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transfer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.call_data)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.target_gas = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_static = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.memory_offset)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.offset_len)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_precompile = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.callee_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transfer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.call_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.call_data);
        }
        if self.target_gas != 0 {
            my_size += ::protobuf::rt::value_size(4, self.target_gas, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_static != false {
            my_size += 2;
        }
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.memory_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.offset_len.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_precompile != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.callee_address.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transfer.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.call_data.is_empty() {
            os.write_bytes(3, &self.call_data)?;
        }
        if self.target_gas != 0 {
            os.write_uint64(4, self.target_gas)?;
        }
        if self.is_static != false {
            os.write_bool(5, self.is_static)?;
        }
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.memory_offset.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.offset_len.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_precompile != false {
            os.write_bool(9, self.is_precompile)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrapData_Call {
        TrapData_Call::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "callee_address",
                |m: &TrapData_Call| { &m.callee_address },
                |m: &mut TrapData_Call| { &mut m.callee_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TrapData_Transfer>>(
                "transfer",
                |m: &TrapData_Call| { &m.transfer },
                |m: &mut TrapData_Call| { &mut m.transfer },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "call_data",
                |m: &TrapData_Call| { &m.call_data },
                |m: &mut TrapData_Call| { &mut m.call_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "target_gas",
                |m: &TrapData_Call| { &m.target_gas },
                |m: &mut TrapData_Call| { &mut m.target_gas },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_static",
                |m: &TrapData_Call| { &m.is_static },
                |m: &mut TrapData_Call| { &mut m.is_static },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TrapData_Context>>(
                "context",
                |m: &TrapData_Call| { &m.context },
                |m: &mut TrapData_Call| { &mut m.context },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UInt256>>(
                "memory_offset",
                |m: &TrapData_Call| { &m.memory_offset },
                |m: &mut TrapData_Call| { &mut m.memory_offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UInt256>>(
                "offset_len",
                |m: &TrapData_Call| { &m.offset_len },
                |m: &mut TrapData_Call| { &mut m.offset_len },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_precompile",
                |m: &TrapData_Call| { &m.is_precompile },
                |m: &mut TrapData_Call| { &mut m.is_precompile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrapData_Call>(
                "TrapData.Call",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrapData_Call {
        static instance: ::protobuf::rt::LazyV2<TrapData_Call> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrapData_Call::new)
    }
}

impl ::protobuf::Clear for TrapData_Call {
    fn clear(&mut self) {
        self.callee_address.clear();
        self.transfer.clear();
        self.call_data.clear();
        self.target_gas = 0;
        self.is_static = false;
        self.context.clear();
        self.memory_offset.clear();
        self.offset_len.clear();
        self.is_precompile = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrapData_Call {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrapData_Call {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrapData_Create {
    // message fields
    pub caller: ::protobuf::SingularPtrField<Address>,
    pub scheme: ::protobuf::SingularPtrField<TrapData_Scheme>,
    pub value: ::protobuf::SingularPtrField<UInt256>,
    pub call_data: ::bytes::Bytes,
    pub target_gas: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrapData_Create {
    fn default() -> &'a TrapData_Create {
        <TrapData_Create as ::protobuf::Message>::default_instance()
    }
}

impl TrapData_Create {
    pub fn new() -> TrapData_Create {
        ::std::default::Default::default()
    }

    // .evm.Address caller = 1;


    pub fn get_caller(&self) -> &Address {
        self.caller.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_caller(&mut self) {
        self.caller.clear();
    }

    pub fn has_caller(&self) -> bool {
        self.caller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller(&mut self, v: Address) {
        self.caller = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caller(&mut self) -> &mut Address {
        if self.caller.is_none() {
            self.caller.set_default();
        }
        self.caller.as_mut().unwrap()
    }

    // Take field
    pub fn take_caller(&mut self) -> Address {
        self.caller.take().unwrap_or_else(|| Address::new())
    }

    // .evm.TrapData.Scheme scheme = 2;


    pub fn get_scheme(&self) -> &TrapData_Scheme {
        self.scheme.as_ref().unwrap_or_else(|| <TrapData_Scheme as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scheme(&mut self) {
        self.scheme.clear();
    }

    pub fn has_scheme(&self) -> bool {
        self.scheme.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheme(&mut self, v: TrapData_Scheme) {
        self.scheme = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheme(&mut self) -> &mut TrapData_Scheme {
        if self.scheme.is_none() {
            self.scheme.set_default();
        }
        self.scheme.as_mut().unwrap()
    }

    // Take field
    pub fn take_scheme(&mut self) -> TrapData_Scheme {
        self.scheme.take().unwrap_or_else(|| TrapData_Scheme::new())
    }

    // .evm.UInt256 value = 3;


    pub fn get_value(&self) -> &UInt256 {
        self.value.as_ref().unwrap_or_else(|| <UInt256 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: UInt256) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut UInt256 {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> UInt256 {
        self.value.take().unwrap_or_else(|| UInt256::new())
    }

    // bytes call_data = 4;


    pub fn get_call_data(&self) -> &[u8] {
        &self.call_data
    }
    pub fn clear_call_data(&mut self) {
        self.call_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_call_data(&mut self, v: ::bytes::Bytes) {
        self.call_data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_call_data(&mut self) -> &mut ::bytes::Bytes {
        &mut self.call_data
    }

    // Take field
    pub fn take_call_data(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.call_data, ::bytes::Bytes::new())
    }

    // uint64 target_gas = 5;


    pub fn get_target_gas(&self) -> u64 {
        self.target_gas
    }
    pub fn clear_target_gas(&mut self) {
        self.target_gas = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_gas(&mut self, v: u64) {
        self.target_gas = v;
    }
}

impl ::protobuf::Message for TrapData_Create {
    fn is_initialized(&self) -> bool {
        for v in &self.caller {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scheme {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.caller)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scheme)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.call_data)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.target_gas = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.caller.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.scheme.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.call_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.call_data);
        }
        if self.target_gas != 0 {
            my_size += ::protobuf::rt::value_size(5, self.target_gas, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.caller.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.scheme.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.call_data.is_empty() {
            os.write_bytes(4, &self.call_data)?;
        }
        if self.target_gas != 0 {
            os.write_uint64(5, self.target_gas)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrapData_Create {
        TrapData_Create::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "caller",
                |m: &TrapData_Create| { &m.caller },
                |m: &mut TrapData_Create| { &mut m.caller },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TrapData_Scheme>>(
                "scheme",
                |m: &TrapData_Create| { &m.scheme },
                |m: &mut TrapData_Create| { &mut m.scheme },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UInt256>>(
                "value",
                |m: &TrapData_Create| { &m.value },
                |m: &mut TrapData_Create| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "call_data",
                |m: &TrapData_Create| { &m.call_data },
                |m: &mut TrapData_Create| { &mut m.call_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "target_gas",
                |m: &TrapData_Create| { &m.target_gas },
                |m: &mut TrapData_Create| { &mut m.target_gas },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrapData_Create>(
                "TrapData.Create",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrapData_Create {
        static instance: ::protobuf::rt::LazyV2<TrapData_Create> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrapData_Create::new)
    }
}

impl ::protobuf::Clear for TrapData_Create {
    fn clear(&mut self) {
        self.caller.clear();
        self.scheme.clear();
        self.value.clear();
        self.call_data.clear();
        self.target_gas = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrapData_Create {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrapData_Create {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EvmResult {
    // message fields
    pub exit_reason: ::protobuf::SingularPtrField<ExitReason>,
    pub return_value: ::bytes::Bytes,
    pub apply: ::protobuf::RepeatedField<Apply>,
    pub logs: ::protobuf::RepeatedField<EvmLog>,
    pub tx_trace: ::protobuf::Chars,
    pub remaining_gas: u64,
    pub continuation_id: u64,
    pub trap_data: ::protobuf::SingularPtrField<TrapData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EvmResult {
    fn default() -> &'a EvmResult {
        <EvmResult as ::protobuf::Message>::default_instance()
    }
}

impl EvmResult {
    pub fn new() -> EvmResult {
        ::std::default::Default::default()
    }

    // .evm.ExitReason exit_reason = 1;


    pub fn get_exit_reason(&self) -> &ExitReason {
        self.exit_reason.as_ref().unwrap_or_else(|| <ExitReason as ::protobuf::Message>::default_instance())
    }
    pub fn clear_exit_reason(&mut self) {
        self.exit_reason.clear();
    }

    pub fn has_exit_reason(&self) -> bool {
        self.exit_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exit_reason(&mut self, v: ExitReason) {
        self.exit_reason = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exit_reason(&mut self) -> &mut ExitReason {
        if self.exit_reason.is_none() {
            self.exit_reason.set_default();
        }
        self.exit_reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_exit_reason(&mut self) -> ExitReason {
        self.exit_reason.take().unwrap_or_else(|| ExitReason::new())
    }

    // bytes return_value = 2;


    pub fn get_return_value(&self) -> &[u8] {
        &self.return_value
    }
    pub fn clear_return_value(&mut self) {
        self.return_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_return_value(&mut self, v: ::bytes::Bytes) {
        self.return_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_return_value(&mut self) -> &mut ::bytes::Bytes {
        &mut self.return_value
    }

    // Take field
    pub fn take_return_value(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.return_value, ::bytes::Bytes::new())
    }

    // repeated .evm.Apply apply = 3;


    pub fn get_apply(&self) -> &[Apply] {
        &self.apply
    }
    pub fn clear_apply(&mut self) {
        self.apply.clear();
    }

    // Param is passed by value, moved
    pub fn set_apply(&mut self, v: ::protobuf::RepeatedField<Apply>) {
        self.apply = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apply(&mut self) -> &mut ::protobuf::RepeatedField<Apply> {
        &mut self.apply
    }

    // Take field
    pub fn take_apply(&mut self) -> ::protobuf::RepeatedField<Apply> {
        ::std::mem::replace(&mut self.apply, ::protobuf::RepeatedField::new())
    }

    // repeated .evm.EvmLog logs = 4;


    pub fn get_logs(&self) -> &[EvmLog] {
        &self.logs
    }
    pub fn clear_logs(&mut self) {
        self.logs.clear();
    }

    // Param is passed by value, moved
    pub fn set_logs(&mut self, v: ::protobuf::RepeatedField<EvmLog>) {
        self.logs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logs(&mut self) -> &mut ::protobuf::RepeatedField<EvmLog> {
        &mut self.logs
    }

    // Take field
    pub fn take_logs(&mut self) -> ::protobuf::RepeatedField<EvmLog> {
        ::std::mem::replace(&mut self.logs, ::protobuf::RepeatedField::new())
    }

    // string tx_trace = 5;


    pub fn get_tx_trace(&self) -> &str {
        &self.tx_trace
    }
    pub fn clear_tx_trace(&mut self) {
        ::protobuf::Clear::clear(&mut self.tx_trace);
    }

    // Param is passed by value, moved
    pub fn set_tx_trace(&mut self, v: ::protobuf::Chars) {
        self.tx_trace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_trace(&mut self) -> &mut ::protobuf::Chars {
        &mut self.tx_trace
    }

    // Take field
    pub fn take_tx_trace(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.tx_trace, ::protobuf::Chars::new())
    }

    // uint64 remaining_gas = 6;


    pub fn get_remaining_gas(&self) -> u64 {
        self.remaining_gas
    }
    pub fn clear_remaining_gas(&mut self) {
        self.remaining_gas = 0;
    }

    // Param is passed by value, moved
    pub fn set_remaining_gas(&mut self, v: u64) {
        self.remaining_gas = v;
    }

    // uint64 continuation_id = 7;


    pub fn get_continuation_id(&self) -> u64 {
        self.continuation_id
    }
    pub fn clear_continuation_id(&mut self) {
        self.continuation_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_continuation_id(&mut self, v: u64) {
        self.continuation_id = v;
    }

    // .evm.TrapData trap_data = 8;


    pub fn get_trap_data(&self) -> &TrapData {
        self.trap_data.as_ref().unwrap_or_else(|| <TrapData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_trap_data(&mut self) {
        self.trap_data.clear();
    }

    pub fn has_trap_data(&self) -> bool {
        self.trap_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trap_data(&mut self, v: TrapData) {
        self.trap_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trap_data(&mut self) -> &mut TrapData {
        if self.trap_data.is_none() {
            self.trap_data.set_default();
        }
        self.trap_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_trap_data(&mut self) -> TrapData {
        self.trap_data.take().unwrap_or_else(|| TrapData::new())
    }
}

impl ::protobuf::Message for EvmResult {
    fn is_initialized(&self) -> bool {
        for v in &self.exit_reason {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apply {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.logs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trap_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exit_reason)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.return_value)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.apply)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logs)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.tx_trace)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.remaining_gas = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.continuation_id = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trap_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.exit_reason.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.return_value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.return_value);
        }
        for value in &self.apply {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.logs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.tx_trace.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.tx_trace);
        }
        if self.remaining_gas != 0 {
            my_size += ::protobuf::rt::value_size(6, self.remaining_gas, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.continuation_id != 0 {
            my_size += ::protobuf::rt::value_size(7, self.continuation_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.trap_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.exit_reason.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.return_value.is_empty() {
            os.write_bytes(2, &self.return_value)?;
        }
        for v in &self.apply {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.logs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.tx_trace.is_empty() {
            os.write_string(5, &self.tx_trace)?;
        }
        if self.remaining_gas != 0 {
            os.write_uint64(6, self.remaining_gas)?;
        }
        if self.continuation_id != 0 {
            os.write_uint64(7, self.continuation_id)?;
        }
        if let Some(ref v) = self.trap_data.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EvmResult {
        EvmResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExitReason>>(
                "exit_reason",
                |m: &EvmResult| { &m.exit_reason },
                |m: &mut EvmResult| { &mut m.exit_reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                "return_value",
                |m: &EvmResult| { &m.return_value },
                |m: &mut EvmResult| { &mut m.return_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Apply>>(
                "apply",
                |m: &EvmResult| { &m.apply },
                |m: &mut EvmResult| { &mut m.apply },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EvmLog>>(
                "logs",
                |m: &EvmResult| { &m.logs },
                |m: &mut EvmResult| { &mut m.logs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                "tx_trace",
                |m: &EvmResult| { &m.tx_trace },
                |m: &mut EvmResult| { &mut m.tx_trace },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "remaining_gas",
                |m: &EvmResult| { &m.remaining_gas },
                |m: &mut EvmResult| { &mut m.remaining_gas },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "continuation_id",
                |m: &EvmResult| { &m.continuation_id },
                |m: &mut EvmResult| { &mut m.continuation_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TrapData>>(
                "trap_data",
                |m: &EvmResult| { &m.trap_data },
                |m: &mut EvmResult| { &mut m.trap_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EvmResult>(
                "EvmResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EvmResult {
        static instance: ::protobuf::rt::LazyV2<EvmResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EvmResult::new)
    }
}

impl ::protobuf::Clear for EvmResult {
    fn clear(&mut self) {
        self.exit_reason.clear();
        self.return_value.clear();
        self.apply.clear();
        self.logs.clear();
        ::protobuf::Clear::clear(&mut self.tx_trace);
        self.remaining_gas = 0;
        self.continuation_id = 0;
        self.trap_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EvmResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EvmResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\tEvm.proto\x12\x03evm\")\n\x07UInt128\x12\x0e\n\x02x0\x18\x01\x20\x01\
    (\x04R\x02x0\x12\x0e\n\x02x1\x18\x02\x20\x01(\x04R\x02x1\"I\n\x07UInt256\
    \x12\x0e\n\x02x0\x18\x01\x20\x01(\x04R\x02x0\x12\x0e\n\x02x1\x18\x02\x20\
    \x01(\x04R\x02x1\x12\x0e\n\x02x2\x18\x03\x20\x01(\x04R\x02x2\x12\x0e\n\
    \x02x3\x18\x04\x20\x01(\x04R\x02x3\"9\n\x07Address\x12\x0e\n\x02x0\x18\
    \x01\x20\x01(\x07R\x02x0\x12\x0e\n\x02x1\x18\x02\x20\x01(\x06R\x02x1\x12\
    \x0e\n\x02x2\x18\x03\x20\x01(\x06R\x02x2\"F\n\x04H256\x12\x0e\n\x02x0\
    \x18\x01\x20\x01(\x06R\x02x0\x12\x0e\n\x02x1\x18\x02\x20\x01(\x06R\x02x1\
    \x12\x0e\n\x02x2\x18\x03\x20\x01(\x06R\x02x2\x12\x0e\n\x02x3\x18\x04\x20\
    \x01(\x06R\x02x3\"\xf4\x01\n\rEvmEvalExtras\x12\x19\n\x08chain_id\x18\
    \x01\x20\x01(\rR\x07chainId\x12'\n\x0fblock_timestamp\x18\x02\x20\x01(\
    \x04R\x0eblockTimestamp\x12&\n\x0fblock_gas_limit\x18\x03\x20\x01(\x04R\
    \rblockGasLimit\x12)\n\x10block_difficulty\x18\x04\x20\x01(\x04R\x0fbloc\
    kDifficulty\x12!\n\x0cblock_number\x18\x05\x20\x01(\x04R\x0bblockNumber\
    \x12)\n\tgas_price\x18\x06\x20\x01(\x0b2\x0c.evm.UInt256R\x08gasPrice\"1\
    \n\x07Storage\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\x0cR\x05value\"\xfc\x02\n\x05Apply\x12+\n\x06\
    modify\x18\x01\x20\x01(\x0b2\x11.evm.Apply.ModifyH\0R\x06modify\x12+\n\
    \x06delete\x18\x02\x20\x01(\x0b2\x11.evm.Apply.DeleteH\0R\x06delete\x1a0\
    \n\x06Delete\x12&\n\x07address\x18\x01\x20\x01(\x0b2\x0c.evm.AddressR\
    \x07address\x1a\xdd\x01\n\x06Modify\x12&\n\x07address\x18\x01\x20\x01(\
    \x0b2\x0c.evm.AddressR\x07address\x12&\n\x07balance\x18\x02\x20\x01(\x0b\
    2\x0c.evm.UInt256R\x07balance\x12\"\n\x05nonce\x18\x03\x20\x01(\x0b2\x0c\
    .evm.UInt256R\x05nonce\x12\x12\n\x04code\x18\x04\x20\x01(\x0cR\x04code\
    \x12&\n\x07storage\x18\x05\x20\x03(\x0b2\x0c.evm.StorageR\x07storage\x12\
    #\n\rreset_storage\x18\x06\x20\x01(\x08R\x0cresetStorageB\x07\n\x05apply\
    \"\xa5\x03\n\x0cContinuation\x12\x0e\n\x02id\x18\x01\x20\x01(\x04R\x02id\
    \x12;\n\rfeedback_type\x18\x02\x20\x01(\x0e2\x16.evm.Continuation.TypeR\
    \x0cfeedbackType\x12(\n\x07address\x18\x03\x20\x01(\x0b2\x0c.evm.Address\
    H\0R\x07address\x124\n\x08calldata\x18\x04\x20\x01(\x0b2\x16.evm.Continu\
    ation.CallH\0R\x08calldata\x12\x1f\n\x04logs\x18\x05\x20\x03(\x0b2\x0b.e\
    vm.EvmLogR\x04logs\x12\x1c\n\tsucceeded\x18\x06\x20\x01(\x08R\tsucceeded\
    \x1az\n\x04Call\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x121\n\r\
    memory_offset\x18\x02\x20\x01(\x0b2\x0c.evm.UInt256R\x0cmemoryOffset\x12\
    +\n\noffset_len\x18\x03\x20\x01(\x0b2\x0c.evm.UInt256R\toffsetLen\"\x1c\
    \n\x04Type\x12\x08\n\x04CALL\x10\0\x12\n\n\x06CREATE\x10\x01B\x0f\n\rfee\
    dback_data\"\x9a\x04\n\x07EvmArgs\x12&\n\x07address\x18\x01\x20\x01(\x0b\
    2\x0c.evm.AddressR\x07address\x12$\n\x06origin\x18\x02\x20\x01(\x0b2\x0c\
    .evm.AddressR\x06origin\x12\x12\n\x04code\x18\x03\x20\x01(\x0cR\x04code\
    \x12\x12\n\x04data\x18\x04\x20\x01(\x0cR\x04data\x123\n\x0eapparent_valu\
    e\x18\x05\x20\x01(\x0b2\x0c.evm.UInt256R\rapparentValue\x12\x1b\n\tgas_l\
    imit\x18\x06\x20\x01(\x04R\x08gasLimit\x12*\n\x06extras\x18\x07\x20\x01(\
    \x0b2\x12.evm.EvmEvalExtrasR\x06extras\x12\x1a\n\x08estimate\x18\x08\x20\
    \x01(\x08R\x08estimate\x12\x18\n\x07context\x18\t\x20\x01(\tR\x07context\
    \x125\n\x0ccontinuation\x18\n\x20\x01(\x0b2\x11.evm.ContinuationR\x0ccon\
    tinuation\x12\x1d\n\nenable_cps\x18\x0b\x20\x01(\x08R\tenableCps\x12(\n\
    \x10tx_trace_enabled\x18\x0c\x20\x01(\x08R\x0etxTraceEnabled\x12\x19\n\
    \x08tx_trace\x18\r\x20\x01(\tR\x07txTrace\x12$\n\x0eis_static_call\x18\
    \x0e\x20\x01(\x08R\x0cisStaticCall\x12$\n\x06caller\x18\x0f\x20\x01(\x0b\
    2\x0c.evm.AddressR\x06caller\"g\n\x06EvmLog\x12&\n\x07address\x18\x01\
    \x20\x01(\x0b2\x0c.evm.AddressR\x07address\x12!\n\x06topics\x18\x02\x20\
    \x03(\x0b2\t.evm.H256R\x06topics\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\
    \x04data\"\xa1\x08\n\nExitReason\x123\n\x07succeed\x18\x01\x20\x01(\x0e2\
    \x17.evm.ExitReason.SucceedH\0R\x07succeed\x12-\n\x05error\x18\x02\x20\
    \x01(\x0b2\x15.evm.ExitReason.ErrorH\0R\x05error\x120\n\x06revert\x18\
    \x03\x20\x01(\x0e2\x16.evm.ExitReason.RevertH\0R\x06revert\x12-\n\x05fat\
    al\x18\x04\x20\x01(\x0b2\x15.evm.ExitReason.FatalH\0R\x05fatal\x12*\n\
    \x04trap\x18\x05\x20\x01(\x0b2\x14.evm.ExitReason.TrapH\0R\x04trap\x1a\
    \x82\x03\n\x05Error\x12.\n\x04kind\x18\x01\x20\x01(\x0e2\x1a.evm.ExitRea\
    son.Error.KindR\x04kind\x12!\n\x0cerror_string\x18\x02\x20\x01(\tR\x0ber\
    rorString\"\xa5\x02\n\x04Kind\x12\x13\n\x0fSTACK_UNDERFLOW\x10\0\x12\x12\
    \n\x0eSTACK_OVERFLOW\x10\x01\x12\x10\n\x0cINVALID_JUMP\x10\x02\x12\x11\n\
    \rINVALID_RANGE\x10\x03\x12\x16\n\x12DESIGNATED_INVALID\x10\x04\x12\x11\
    \n\rCALL_TOO_DEEP\x10\x05\x12\x14\n\x10CREATE_COLLISION\x10\x06\x12\x19\
    \n\x15CREATE_CONTRACT_LIMIT\x10\x07\x12\x10\n\x0cINVALID_CODE\x10\x08\
    \x12\x11\n\rOUT_OF_OFFSET\x10\t\x12\x0e\n\nOUT_OF_GAS\x10\n\x12\x0f\n\
    \x0bOUT_OF_FUND\x10\x0b\x12\x10\n\x0cPC_UNDERFLOW\x10\x0c\x12\x10\n\x0cC\
    REATE_EMPTY\x10\r\x12\t\n\x05OTHER\x10\x0e\x1a\xdf\x01\n\x05Fatal\x12.\n\
    \x04kind\x18\x01\x20\x01(\x0e2\x1a.evm.ExitReason.Fatal.KindR\x04kind\
    \x12+\n\x05error\x18\x02\x20\x01(\x0b2\x15.evm.ExitReason.ErrorR\x05erro\
    r\x12!\n\x0cerror_string\x18\x03\x20\x01(\tR\x0berrorString\"V\n\x04Kind\
    \x12\x11\n\rNOT_SUPPORTED\x10\0\x12\x17\n\x13UNHANDLED_INTERRUPT\x10\x01\
    \x12\x17\n\x13CALL_ERROR_AS_FATAL\x10\x02\x12\t\n\x05OTHER\x10\x03\x1a`\
    \n\x04Trap\x12-\n\x04kind\x18\x01\x20\x01(\x0e2\x19.evm.ExitReason.Trap.\
    KindR\x04kind\")\n\x04Kind\x12\x0b\n\x07UNKNOWN\x10\0\x12\x08\n\x04CALL\
    \x10\x01\x12\n\n\x06CREATE\x10\x02\"2\n\x07Succeed\x12\x0b\n\x07STOPPED\
    \x10\0\x12\x0c\n\x08RETURNED\x10\x01\x12\x0c\n\x08SUICIDED\x10\x02\"\x16\
    \n\x06Revert\x12\x0c\n\x08REVERTED\x10\0B\r\n\x0bexit_reason\"\x91\x0b\n\
    \x08TrapData\x12(\n\x04call\x18\x01\x20\x01(\x0b2\x12.evm.TrapData.CallH\
    \0R\x04call\x12.\n\x06create\x18\x02\x20\x01(\x0b2\x14.evm.TrapData.Crea\
    teH\0R\x06create\x1a\x84\x01\n\x08Transfer\x12$\n\x06source\x18\x01\x20\
    \x01(\x0b2\x0c.evm.AddressR\x06source\x12.\n\x0bdestination\x18\x02\x20\
    \x01(\x0b2\x0c.evm.AddressR\x0bdestination\x12\"\n\x05value\x18\x03\x20\
    \x01(\x0b2\x0c.evm.UInt256R\x05value\x1a\x94\x01\n\x07Context\x12.\n\x0b\
    destination\x18\x01\x20\x01(\x0b2\x0c.evm.AddressR\x0bdestination\x12$\n\
    \x06caller\x18\x02\x20\x01(\x0b2\x0c.evm.AddressR\x06caller\x123\n\x0eap\
    parent_value\x18\x03\x20\x01(\x0b2\x0c.evm.UInt256R\rapparentValue\x1a\
    \xc4\x03\n\x06Scheme\x125\n\x06legacy\x18\x01\x20\x01(\x0b2\x1b.evm.Trap\
    Data.Scheme.LegacyH\0R\x06legacy\x128\n\x07create2\x18\x02\x20\x01(\x0b2\
    \x1c.evm.TrapData.Scheme.Create2H\0R\x07create2\x122\n\x05fixed\x18\x03\
    \x20\x01(\x0b2\x1a.evm.TrapData.Scheme.FixedH\0R\x05fixed\x1a.\n\x06Lega\
    cy\x12$\n\x06caller\x18\x01\x20\x01(\x0b2\x0c.evm.AddressR\x06caller\x1a\
    \xad\x01\n\x07Create2\x12$\n\x06caller\x18\x01\x20\x01(\x0b2\x0c.evm.Add\
    ressR\x06caller\x12&\n\tcode_hash\x18\x02\x20\x01(\x0b2\t.evm.H256R\x08c\
    odeHash\x12\x1d\n\x04salt\x18\x03\x20\x01(\x0b2\t.evm.H256R\x04salt\x125\
    \n\x0fcreate2_address\x18\x04\x20\x01(\x0b2\x0c.evm.AddressR\x0ecreate2A\
    ddress\x1a-\n\x05Fixed\x12$\n\x06addres\x18\x01\x20\x01(\x0b2\x0c.evm.Ad\
    dressR\x06addresB\x06\n\x04type\x1a\xfe\x02\n\x04Call\x123\n\x0ecallee_a\
    ddress\x18\x01\x20\x01(\x0b2\x0c.evm.AddressR\rcalleeAddress\x122\n\x08t\
    ransfer\x18\x02\x20\x01(\x0b2\x16.evm.TrapData.TransferR\x08transfer\x12\
    \x1b\n\tcall_data\x18\x03\x20\x01(\x0cR\x08callData\x12\x1d\n\ntarget_ga\
    s\x18\x04\x20\x01(\x04R\ttargetGas\x12\x1b\n\tis_static\x18\x05\x20\x01(\
    \x08R\x08isStatic\x12/\n\x07context\x18\x06\x20\x01(\x0b2\x15.evm.TrapDa\
    ta.ContextR\x07context\x121\n\rmemory_offset\x18\x07\x20\x01(\x0b2\x0c.e\
    vm.UInt256R\x0cmemoryOffset\x12+\n\noffset_len\x18\x08\x20\x01(\x0b2\x0c\
    .evm.UInt256R\toffsetLen\x12#\n\ris_precompile\x18\t\x20\x01(\x08R\x0cis\
    Precompile\x1a\xbc\x01\n\x06Create\x12$\n\x06caller\x18\x01\x20\x01(\x0b\
    2\x0c.evm.AddressR\x06caller\x12,\n\x06scheme\x18\x02\x20\x01(\x0b2\x14.\
    evm.TrapData.SchemeR\x06scheme\x12\"\n\x05value\x18\x03\x20\x01(\x0b2\
    \x0c.evm.UInt256R\x05value\x12\x1b\n\tcall_data\x18\x04\x20\x01(\x0cR\
    \x08callData\x12\x1d\n\ntarget_gas\x18\x05\x20\x01(\x04R\ttargetGasB\x06\
    \n\x04data\"\xb8\x02\n\tEvmResult\x120\n\x0bexit_reason\x18\x01\x20\x01(\
    \x0b2\x0f.evm.ExitReasonR\nexitReason\x12!\n\x0creturn_value\x18\x02\x20\
    \x01(\x0cR\x0breturnValue\x12\x20\n\x05apply\x18\x03\x20\x03(\x0b2\n.evm\
    .ApplyR\x05apply\x12\x1f\n\x04logs\x18\x04\x20\x03(\x0b2\x0b.evm.EvmLogR\
    \x04logs\x12\x19\n\x08tx_trace\x18\x05\x20\x01(\tR\x07txTrace\x12#\n\rre\
    maining_gas\x18\x06\x20\x01(\x04R\x0cremainingGas\x12'\n\x0fcontinuation\
    _id\x18\x07\x20\x01(\x04R\x0econtinuationId\x12*\n\ttrap_data\x18\x08\
    \x20\x01(\x0b2\r.evm.TrapDataR\x08trapDatab\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
