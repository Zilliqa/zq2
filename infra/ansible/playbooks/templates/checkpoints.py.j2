#!/usr/bin/env python3

import os
import glob
import subprocess
import logging
import sys
import requests
import json
from pathlib import Path

# Configuration - replace with your actual values or use environment variables
CHECKPOINT_DIR = "/data/{{ eth_chain_id }}/checkpoints"
GCS_BUCKET = "gs://{{ chain_name }}-checkpoint"
LOG_NAME = "{{ chain_name }}-checkpoint-cron-log"
NODE_URL = "http://localhost:4202"
HEADERS = {"Content-Type": "application/json"}

def setup_logging():
    """Setup logging to syslog (similar to logger command in bash)"""
    logging.basicConfig(
        level=logging.INFO,
        format=f'{LOG_NAME}: %(message)s',
        handlers=[logging.StreamHandler(sys.stdout)]
    )
    return logging.getLogger(__name__)

def log_message(logger, message):
    """Log message (equivalent to logger -t in bash)"""
    logger.info(message)
    # Also log to syslog if available
    try:
        subprocess.run(['logger', '-t', LOG_NAME, message], check=False)
    except FileNotFoundError:
        # logger command not available, already logged to stdout
        pass

def get_rpc_response(method, params=[]):
    """Get response from RPC node"""
    payload = {"jsonrpc": "2.0", "id": 1, "method": method, "params": params}
    try:
        response = requests.post(NODE_URL, json=payload, headers=HEADERS, timeout=3)
        response.raise_for_status()
        response_json = response.json()
        return response_json.get("result")
    except requests.exceptions.RequestException as e:
        return None, f"Request error in {method}: {e}"
    except ValueError as e:
        return None, f"JSON decoding error in {method}: {e}"
    except Exception as e:
        return None, f"Unexpected error in {method}: {e}"

def get_current_block():
    """Get current block number from the node"""
    try:
        block_number_hex = get_rpc_response("eth_blockNumber")
        if isinstance(block_number_hex, tuple):
            return None, block_number_hex[1]
        
        if block_number_hex:
            current_block = int(block_number_hex, 16)
            return current_block, None
        else:
            return None, "No block number returned from node"
    except Exception as e:
        return None, f"Error getting current block: {e}"

def get_checkpoint_files_sorted(checkpoint_dir):
    """Get checkpoint files sorted by modification time (oldest first)"""
    checkpoint_files = []
    
    # Find all files in checkpoint directory, excluding .part files
    pattern = os.path.join(checkpoint_dir, "*")
    for filepath in glob.glob(pattern):
        if os.path.isfile(filepath) and not filepath.endswith('.part'):
            mtime = os.path.getmtime(filepath)
            checkpoint_files.append((mtime, filepath))
    
    # Sort by modification time
    checkpoint_files.sort(key=lambda x: x[0])
    
    # Return just the file paths
    return [filepath for _, filepath in checkpoint_files]

def run_gsutil_command(command):
    """Run gsutil command and return success status"""
    try:
        result = subprocess.run(command, shell=True, check=True, 
                              capture_output=True, text=True)
        return True
    except subprocess.CalledProcessError as e:
        print(f"Command failed: {command}")
        print(f"Error: {e.stderr}")
        return False

def main():
    logger = setup_logging()
    
    # Get current block information
    current_block, block_error = get_current_block()
    block_info = f" (Current block: {current_block})" if current_block else f" (Block info unavailable: {block_error})"
    
    # Check if checkpoint directory exists
    if not os.path.exists(CHECKPOINT_DIR):
        log_message(logger, f"Checkpoint directory {CHECKPOINT_DIR} does not exist{block_info}")
        sys.exit(1)
    
    # Get sorted checkpoint files
    checkpoint_files = get_checkpoint_files_sorted(CHECKPOINT_DIR)
    
    if not checkpoint_files:
        log_message(logger, f"No checkpoint files found{block_info}")
        return
    
    # Process each checkpoint file
    for checkpoint_file in checkpoint_files:
        log_message(logger, f"Processing {checkpoint_file}")
        
        filename = os.path.basename(checkpoint_file)
        
        # Format filename with zero padding (9 digits)
        try:
            formatted_filename = f"{int(filename):09d}"
        except ValueError:
            # If filename is not a number, use as-is
            formatted_filename = filename
        
        # Move existing .dat files to previous directory
        move_cmd = f'gsutil mv "{GCS_BUCKET}/*.dat" "{GCS_BUCKET}/previous/"'
        run_gsutil_command(move_cmd)  # Don't check return value as this might fail if no files exist
        
        # Copy checkpoint file to GCS
        copy_cmd = f'gsutil cp "{checkpoint_file}" "{GCS_BUCKET}/{formatted_filename}.dat"'
        
        if run_gsutil_command(copy_cmd):
            # Get fresh block info for upload confirmation
            fresh_block, fresh_error = get_current_block()
            fresh_block_info = f" (Current block: {fresh_block})" if fresh_block else f" (Block info unavailable: {fresh_error})"
            
            log_message(logger, f"Uploaded {checkpoint_file} to GCS{fresh_block_info}")
            
            # Delete the local file
            try:
                os.remove(checkpoint_file)
                log_message(logger, f"Deleted {checkpoint_file} from local directory")
            except OSError as e:
                log_message(logger, f"Failed to delete {checkpoint_file}: {e}")
        else:
            log_message(logger, f"Failed to upload {checkpoint_file} to GCS")

if __name__ == "__main__":
    main()