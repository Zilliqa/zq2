use std::{path::PathBuf, str::FromStr};

use alloy_consensus::{SignableTransaction, TxEnvelope};
use alloy_contract::{ContractInstance, DynCallBuilder, Interface, SolCallBuilder};
use alloy_dyn_abi::DynSolValue;
use alloy_network::{eip2718::Encodable2718, EthereumWallet, TransactionBuilder, TxSigner};
use alloy_primitives::{Bytes, TxKind};
use alloy_provider::{Provider, ProviderBuilder, WsConnect};
use alloy_pubsub::PubSubFrontend;
use alloy_rpc_types::{BlockNumberOrTag, Filter};
use alloy_rpc_types_eth::{TransactionInput, TransactionRequest};
use alloy_signer::{Signer, SignerSync};
use alloy_signer_local::PrivateKeySigner;
use alloy_sol_types::{sol, SolCall};

use anyhow::Result;
use clap::Parser;
use futures_util::stream::StreamExt;
use lazy_static::lazy_static;
use serde_json::Value;
use tokio::sync::watch;
use tracing::{debug, error, info};
use tracing_subscriber::EnvFilter;
use zilliqa::{
    contracts,
    crypto::{NodePublicKey, SecretKey},
    state::contract_addr,
    uccb::{
        cfg::{ChainConfig, Config, ZQ2Config},
        client::ChainClient,
    },
};

// The json files are generated by invoking 'forge build' in zilliqa/src/contracts/uccb
sol!(
    #[sol(abi)]
    ValidatorManager,
    "src/contracts/uccb/out/ValidatorManager.sol/ValidatorManager.json"
);

sol!(
    #[sol(abi)]
    Deposit,
    "src/contracts/compiled/Deposit.json"
);

#[derive(Parser, Debug)]
struct Args {
    #[arg(value_parser = SecretKey::from_hex)]
    secret_key: SecretKey,
    #[clap(long, short, default_value = "config.toml")]
    config_file: PathBuf,
}

impl zilliqa::uccb::Args for Args {
    fn secret_key(&self) -> &SecretKey {
        &self.secret_key
    }

    fn config_file(&self) -> &PathBuf {
        &self.config_file
    }
}

struct ValidatorOracle {
    wallet: PrivateKeySigner,
    zq2_config: ZQ2Config,
    chain_clients: Vec<ChainClient>,
}

impl ValidatorOracle {
    pub async fn new(secret_key: SecretKey, config: Config) -> Result<Self> {
        let wallet = PrivateKeySigner::from_str(secret_key.to_hex().as_str())?;
        let mut chain_clients = vec![Self::create_zq2_chain_client(config.clone(), &wallet).await?];
        for chain_config in config.chain_configs {
            chain_clients.push(
                ChainClient::new(
                    &chain_config,
                    config.zq2.validator_manager_address,
                    wallet.clone(),
                )
                .await?,
            );
        }

        Ok(Self {
            wallet,
            zq2_config: config.zq2,
            chain_clients,
        })
    }

    pub async fn start(&mut self) -> Result<()> {
        /*
        info!(
            "Starting validator oracle with wallet address {}",
            self.wallet.address()
        );
        */

        let validators = self.get_stakers().await?;
        info!("Current validator set is: {validators:?}");

        let (sender, receiver) = watch::channel(validators);

        let mut handles = vec![];
        for chain_client in &self.chain_clients {
            let mut receiver = receiver.clone();
            let chain_client = chain_client.clone();
            let handle = tokio::spawn(async move {
                loop {
                    let validators = receiver.borrow_and_update().clone();
                    if Self::update_validator_manager(&chain_client, &validators)
                        .await
                        .is_err()
                    {
                        error!(
                            "Failed updating the validator manager on {}",
                            chain_client.rpc_url
                        );
                    }

                    if receiver.changed().await.is_err() {
                        break;
                    }
                }
            });
            handles.push(handle);
        }

        let result = self.listen_to_staker_updates(sender).await;

        for handle in handles {
            handle.await?;
        }

        result
    }

    async fn listen_to_staker_updates(
        &mut self,
        sender: watch::Sender<Vec<NodePublicKey>>,
    ) -> Result<()> {
        let filter = Filter::new()
            .address(contract_addr::DEPOSIT)
            // Must be the same signature as the event in deposit.sol
            .event("StakerAdded(bytes)")
            .from_block(BlockNumberOrTag::Finalized);

        let ws = WsConnect::new(&self.zq2_config.rpc_url);
        let provider = ProviderBuilder::new().on_ws(ws).await?;

        let subscription = provider.subscribe_logs(&filter).await?;
        let mut stream = subscription.into_stream();
        while let Some(log) = stream.next().await {
            // TODO: infer if staker added or removed
            info!("Received validator update: {log:?}");

            let validators = self.get_stakers().await?;
            info!("Updating chains to the current validator set to: {validators:?}");

            sender.send(validators)?;
        }

        Ok(())
    }

    async fn create_zq2_chain_client(
        config: Config,
        wallet: &PrivateKeySigner,
    ) -> Result<ChainClient> {
        ChainClient::new(
            &ChainConfig {
                rpc_url: config.zq2.rpc_url,
                chain_gateway_address: config.zq2.chain_gateway_address,
                chain_gateway_block_deployed: 0,
                block_instant_finality: None,
                legacy_gas_estimation: None,
            },
            config.zq2.validator_manager_address,
            wallet.clone(),
        )
        .await
    }

    async fn get_stakers(&self) -> Result<Vec<NodePublicKey>> {
        debug!("Retreiving validators from the deposit contract");

        println!("Deposit contract address: {}", contract_addr::DEPOSIT);
        let zq2_chain_client = &self.chain_clients[0];

        let contract: ContractInstance<alloy_pubsub::PubSubFrontend, _> = ContractInstance::new(
            contract_addr::DEPOSIT,
            zq2_chain_client.client.as_ref(),
            Interface::new(Deposit::abi::contract()),
        );

        let call_builder: DynCallBuilder<_, _, _> = contract.function("getStakers", &vec![])?;
        let value = call_builder.call().await?;
        let validators = if value.len() == 1 {
            value[0]
                .as_array().unwrap()
                .iter()
                .map(|k| NodePublicKey::from_bytes(&k.as_bytes().unwrap()).unwrap())
                .collect()
        } else {
            vec![]
        };

        Ok(validators)
    }

    async fn update_validator_manager(
        chain_client: &ChainClient,
        validators: &[NodePublicKey],
    ) -> Result<()> {
        /*
        let validator_manager = ValidatorManager::new(
            chain_client.validator_manager_address,
            chain_client.client.clone(),
        );
        */

        /*
        let validators = validators
            .iter()
            .map(|validator| H160(**validator.into_addr()))
            .collect();
        let call = validator_manager.set_validators(validators);
        let pending_tx = call.send().await?;
        if let Some(receipt) = pending_tx.await? {
            info!(
                "Updated {}: {}",
                &chain_client.rpc_url,
                serde_json::to_string(&receipt)?
            );
        } else {
            error!(
                "No receipt received when updating {}...",
                &chain_client.rpc_url
            );
        }
        */

        Ok(())
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    let args = Args::parse();
    let config = zilliqa::uccb::read_config(&args)?;

    let builder = tracing_subscriber::fmt()
        .with_env_filter(EnvFilter::from_default_env())
        .with_line_number(true);
    builder.init();

    let mut validator_oracle = ValidatorOracle::new(args.secret_key, config).await?;
    validator_oracle.start().await
}
